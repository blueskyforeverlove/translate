## 第十一章 字符串和二进制

本章内容：

* String模块和字符串（string）
* 字符列表（character lists）
* 处理字符串和其模式匹配

我们一直很开心的用着字符串却没有专门讨论，现在是时候学习字符串了。

### 字符串定义

Elixir有两种字符表示：单引号和双引号包裹的字符。除了最本质的不同职务，其他还是有很多共同之处的。

字符串是由UTF-8编码的字符组成的。


They may contain escape sequences: \a

BEL (0x07)

\b

BS (0x08)

\d

DEL (0x7f)

\e

ESC (0x1b)

\f

FF (0x0c)

\n

NL (0x0a)





\r



CR (0x0d)



\s



SP (0x20)



\t



TAB (0x09)





\v



VT (0x0b)



\xhhh



1–6 hex digits





They allow interpolation on Elixir expressions using the syntax #{...}. iex> name = "dave"



"dave"



iex> "Hello, #{String.capitalize name}!"



"Hello, Dave!"





Characters that would otherwise have special meaning can be escaped with a backslash.

They support heredocs.





Heredocs


Any string can span several lines. To illustrate this, we’ll use both IO.puts and IO.write. We use write for the multiline string because puts always appends a newline, and we want to see the contents without this.

IO.puts "start"



IO.write "



my



string



"



IO.puts "end"





produces:

start





my



string



end





Notice how the multiline string retains the leading and trailing newlines and the leading spaces on the intermediate lines.

The heredoc notation fixes this. Triple the string delimiter (''' or """) and indent the trailing delimiter to the same margin as your string contents, and you get this:

IO.puts "start"



IO.write """



my



string



"""



IO.puts "end"





produces:

start



my



string



end





Heredocs are used extensively to add documentation to functions and modules.





Sigils


Like Ruby, Elixir has an alternative syntax for some literals. We’ve already seen it with regular expressions, where we wrote ~r{...}. In Elixir, these ~-style literals are called sigils (a symbol with magical powers).

A sigil starts with a tilde, followed by an upper- or lowercase letter, some delimited content, and perhaps some options. The delimiters can be <…>, {…}, […], (…), |…|, /…/, "…", and '…'.

The letter determines the sigil’s type:

~C



A character list with no escaping or interpolation





~c



A character list, escaped and interpolated just like a single-quoted string





~R



A regular expression with no escaping or interpolation





~r



A regular expression, escaped and interpolated





~S



A string with no escaping or interpolation





~s



A string, escaped and interpolated just like a double-quoted string





~W



A list of whitespace-delimited words, with no escaping or interpolation





~w



A list of whitespace-delimited words, with escaping and interpolation





Here are some examples, using a variety of delimiters.

iex> ~C[1\n2#{1+2}]



'1\\n2\#{1+2}'



iex> ~c"1\n2#{1+2}"



'1\n23'



iex> ~S[1\n2#{1+2}]



"1\\n2\#{1+2}"



iex> ~s/1\n2#{1+2}/



"1\n23"



iex> ~W[the c#{'a'}t sat on the mat]



["the", "c\#{'a'}t", "sat", "on", "the", "mat"]



iex> ~w[the c#{'a'}t sat on the mat]



["the", "cat", "sat", "on", "the", "mat"]





The ~W and ~w sigils take an optional type specifier, a, c, or s, which determines whether it returns atoms, a list, or strings of characters. (We’ve already seen the ~r options.)

iex> ~w[the c#{'a'}t sat on the mat]a



[:the, :cat, :sat, :on, :the, :mat]



iex> ~w[the c#{'a'}t sat on the mat]c



['the', 'cat', 'sat', 'on', 'the', 'mat']



iex> ~w[the c#{'a'}t sat on the mat]s



["the", "cat", "sat", "on", "the", "mat"]





The delimiter can be any nonword character. If it is (, [, {, or <, then the terminating delimiter is the corresponding closing character. Otherwise the terminating delimiter is the next nonescaped occurrence of the opening delimiter.

Elixir does not check the nesting of delimiters, so the sigil ~s{a{b} is the three-character string a{b.

If the opening delimiter is three single or three double quotes, the sigil is treated as a heredoc.

iex> ~w"""



...> the



...> cat



...> sat



...> """



["the", "cat", "sat"]





If you want to specify modifiers with heredoc sigils (most commonly you’d do this with ~r), add them after the trailing delimiter.

iex> ~r"""



...> hello



...> """i



~r/hello\n/i





One of the interesting things about sigils is that you can define your own. We talk about this in Part III,.





The Name “strings”


Before we get further into this, I need to explain something. In most other languages, you’d call 'cat' and "cat" both strings. And that’s what I’ve been doing so far. But Elixir has a different convention.

In Elixir, the convention is that we call only double-quoted strings “strings.” The single-quoted form is a character list.

This is important. The single- and double-quoted forms are very different, and libraries that work on strings work only on the double-quoted form.

Let’s explore the differences in more detail.





Single-Quoted Strings—Lists of Character Codes


Single-quoted strings are represented as a list of integer values, each value corresponding to a codepoint in the string. For this reason, we refer to them as character lists (or char lists).

iex> str = 'wombat'



'wombat'



iex> is_list str



true



iex> length str



6



iex> Enum.reverse str



'tabmow'





This is confusing: iex says it is a list, but it shows the value as a string. That’s because iex prints a list of integers as a string if it believes each number in the list is a printable character. You can try this for yourself.

iex> [ 67, 65, 84 ]



'CAT'





You can look at the internal representation in a number of ways:

iex> str = 'wombat'



'wombat'



iex> :io.format "~w~n", [ str ]



[119,111,109,98,97,116]



:ok



iex> List.to_tuple str



{119, 111, 109, 98, 97, 116}



iex> str ++ [0]



[119, 111, 109, 98, 97, 116, 0]





The ~w in the format string forces str to be written as an Erlang term—the underlying list of integers. The ~n is a newline.

The last example creates a new character list with a null byte at the end. iex no longer thinks all the bytes are printable, and so returns the underlying character codes.

If a character list contains characters Erlang considers nonprintable, you’ll see the list representation.

iex> '∂x/∂y'



[8706, 120, 47, 8706, 121]





Because a character list is a list, we can use the usual pattern matching and List functions.

iex> 'pole' ++ 'vault'



'polevault'



iex> 'pole' -- 'vault'



'poe'



iex> List.zip [ 'abc', '123' ]



[{97, 49}, {98, 50}, {99, 51}]



iex> [ head | tail ] = 'cat'



'cat'



iex> head



99



iex> tail



'at'



iex> [ head | tail ]



'cat'





Why is the head of 'cat' 99 and not c?. Remember that a char list is just a list of integer character codes, so each individual entry is a number. It happens that 99 is the code for a lowercase c.

In fact, the notation ?c returns the integer code for the character c. This is often useful when employing patterns to extract information from character lists. Here’s a simple module that parses the character-list representation of an optionally signed decimal number.

strings/parse.exs

defmodule Parse do





def number([ ?- | tail ]), do: _number_digits(tail, 0) * -1



def number([ ?+ | tail ]), do: _number_digits(tail, 0)



def number(str), do: _number_digits(str, 0)





defp _number_digits([], value), do: value



defp _number_digits([ digit | tail ], value)



when digit in '0123456789' do



_number_digits(tail, value*10 + digit - ?0)



end



defp _number_digits([ non_digit | _ ], _) do



raise "Invalid digit '#{[non_digit]}'"



end



end





Let’s try it in iex.

iex> c("parse.exs")



[Parse]



iex> Parse.number('123')



123



iex> Parse.number('-123')



-123



iex> Parse.number('+123')



123



iex> Parse.number('+9')



9



iex> Parse.number('+a')



** (RuntimeError) Invalid digit 'a'





Your Turn


Exercise: StringsAndBinaries-1

Write a function that returns true if a single-quoted string contains only printable ASCII characters (space through tilde).



Exercise: StringsAndBinaries-2

Write an anagram?(word1, word2) that returns true if its parameters are anagrams.



Exercise: StringsAndBinaries-3

Try the following in iex: iex> [ 'cat' | 'dog' ]



['cat',100,111,103]





Why does iex print 'cat' as a string, but 'dog' as individual numbers?



Exercise: StringsAndBinaries-4

(Hard) Write a function that takes a single-quoted string of the form number [+-*/] number and returns the result of the calculation. The individual numbers do not have leading plus or minus signs.

calculate('123 + 27') # => 150





Binaries


The binary type represents a sequence of bits.

A binary literal looks like << term,… >>.

The simplest term is just a number from 0 to 255. The numbers are stored as successive bytes in the binary.

iex> b = << 1, 2, 3 >>



<<1, 2, 3>>



iex> byte_size b



3



iex> bit_size b



24





You can specify modifiers to set any term’s size (in bits). This is useful when working with binary formats such as media files and network packets.

iex> b = << 1::size(2), 1::size(3) >>



<<9::size(5)>>



iex> byte_size b



1



iex> bit_size b



5





You can store integers, floats, and other binaries in binaries.

iex> int = << 1 >>



<<1>>



iex> float = << 2.5 :: float >>



<<64, 4, 0, 0, 0, 0, 0, 0>>



iex> mix = << int :: binary, float :: binary >>



<<1, 64, 4, 0, 0, 0, 0, 0, 0>>





Let’s finish an initial look at binaries with an example of bit extraction. An IEEE 754 float has a sign bit, 11 bits of exponent, and 52 bits of mantissa. The exponent is biased by 1023, and the mantissa is a fraction with the top bit assumed to be 1. So we can extract the fields and then use :math.pow, which performs exponentiation, to reassemble the number:

iex> << sign::size(1), exp::size(11), mantissa::size(52) >> = << 3.14159::float >>



iex> (1 + mantissa / :math.pow(2, 52)) * :math.pow(2, exp-1023)



3.14159





Double-Quoted Strings Are Binaries


Whereas single-quoted strings are stored as char lists, the contents of a double-quoted string (dqs) are stored as a consecutive sequence of bytes in UTF-8 encoding. Clearly this is more efficient in terms of memory and certain forms of access, but it does have two implications.

First, because UTF-8 characters can take more than a single byte to represent, the size of the binary is not necessarily the length of the string.

iex> dqs = "∂x/∂y"



"∂x/∂y"



iex> String.length dqs



5



iex> byte_size dqs



9



iex> String.at(dqs, 0)



"∂"



iex> String.codepoints(dqs)



["∂", "x", "/", "∂", "y"]



iex> String.split(dqs, "/")



["∂x", "∂y"]





Second, because you’re no longer using lists, you need to learn and work with the binary syntax alongside the list syntax in your code.





Strings and Elixir Libraries


When Elixir library documentation uses the word string (and most of the time it uses the word binary), it means double-quoted strings.

The String module defines a number of functions that work with double-quoted strings.

at(str, offset)

Returns the grapheme at the given offset (starting at 0). Negative offsets count from the end of the string.



iex> String.at("∂og", 0)



"∂"



iex> String.at("∂og", -1)



"g"





capitalize(str)

Converts str to lowercase, and then capitalizes the first character.



iex> String.capitalize "école"



"École"



iex> String.capitalize "ÎÎÎÎÎ"



"Îîîîî"





codepoints(str)

Returns the codepoints in str.



iex> String.codepoints("José's ∂øg")



["J", "o", "s", "é", "'", "s", " ", "∂", "ø", "g"]





downcase(str)

Converts str to lowercase.



iex> String.downcase "ØRSteD"



"ørsted"





duplicate(str, n)

Returns a string containing n copies of str.



iex> String.duplicate "Ho! ", 3



"Ho! Ho! Ho! "





ends_with?(str, suffix | [ suffixes ])

True if str ends with any of the given suffixes.



iex> String.ends_with? "string", ["elix", "stri", "ring"]



true





first(str)

Returns the first grapheme from str.



iex> String.first "∂og"



"∂"





graphemes(str)

Returns the graphemes in the string. This is different from the codepoints function, which lists combining characters separately.



last(str)

Returns the last grapheme from str.



iex> String.last "∂og"



"g"





length(str)

Returns the number of graphemes in str.



iex> String.length "∂x/∂y"



5





ljust(str, new_length, padding \\ " ")

Returns a new string, at least new_length characters long, containing str left-justified and padded with padding.



iex> String.ljust("cat", 5)



"cat "





lstrip(str)

Removes leading whitespace from str.



iex> String.lstrip "\t\f Hello\t\n"



"Hello\t\n"





lstrip(str, character)

Removes leading copies of character (an integer codepoint) from str.



iex> String.lstrip "!!!SALE!!!", ?!



"SALE!!!"





next_codepoint(str)

Splits str into its leading codepoint and the rest, or nil if str is empty. This may be used as the basis of an iterator.



strings/nextcodepoint.ex

defmodule MyString do



def each(str, func), do: _each(String.next_codepoint(str), func)





defp _each({codepoint, rest}, func) do



func.(codepoint)



_each(String.next_codepoint(rest), func)



end





defp _each(nil, _), do: []



end





MyString.each "∂og", fn c -> IO.puts c end





produces:

∂



o



g





next_grapheme(str)

Same as next_codepoint, but returns graphemes (and :no_grapheme on completion).



printable?(str)

Returns true if str contains only printable characters.



iex> String.printable? "José"



true



iex> String.printable? "\x{0000} a null"



false





replace(str, pattern, replacement, options \\ [global: true, insert_replaced: nil])

Replaces pattern with replacement in str under control of options.



If the :global option is true, all occurrences of the pattern are replaced; otherwise only the first is replaced.



If :insert_replaced is set to a number, the pattern is inserted into the replacement at that offset. If the option is a list, it is inserted multiple times.



iex> String.replace "the cat on the mat", "at", "AT"



"the cAT on the mAT"



iex> String.replace "the cat on the mat", "at", "AT", global: false



"the cAT on the mat"



iex> String.replace "the cat on the mat", "at", "AT", insert_replaced: 0



"the catAT on the matAT"



iex> String.replace "the cat on the mat", "at", "AT", insert_replaced: [0,2]



"the catATat on the matATat"





reverse(str)

Reverses the graphemes in a string.



iex> String.reverse "pupils"



"slipup"



iex> String.reverse "∑ƒ÷∂"



"∂÷ƒ∑"





rjust(str, new_length, padding \\ " ")

Returns a new string, at least new_length characters long, containing str right-justified and padded with padding.



iex> String.rjust("cat", 5, ?>)



">>cat"





rstrip(str)

Removes trailing whitespace from str.



iex> String.rstrip(" line \r\n")



" line"





rstrip(str, character)

Removes trailing occurrences of character from str.



iex> String.rstrip "!!!SALE!!!", ?!



"!!!SALE"





slice(str, offset, len)

Returns a len character substring starting at offset (measured from the end of str if negative).



iex> String.slice "the cat on the mat", 4, 3



"cat"



iex> String.slice "the cat on the mat", -3, 3



"mat"





split(str, pattern \\ nil, options \\ [global: true])

Splits str into substrings delimited by pattern. If :global is false, only one split is performed. pattern can be a string, a regular expression, or nil. In the latter case, the string is split on whitespace.



iex> String.split " the cat on the mat "



["the", "cat", "on", "the", "mat"]



iex> String.split "the cat on the mat", "t"



["", "he ca", " on ", "he ma", ""]



iex> String.split "the cat on the mat", ~r{[ae]}



["th", " c", "t on th", " m", "t"]



iex> String.split "the cat on the mat", ~r{[ae]}, parts: 2



["th", " cat on the mat"]





starts_with?(str, prefix | [ prefixes ])

True if str starts with any of the given prefixes.



iex> String.starts_with? "string", ["elix", "stri", "ring"]



true





strip(str)

Strips leading and trailing whitespace from str.



iex> String.strip "\t Hello \r\n"



"Hello"





strip(str, character)

Strips leading and trailing instances of character from str.



iex> String.strip "!!!SALE!!!", ?!



"SALE"





upcase(str)

Returns an uppercase version of str.



iex> String.upcase "José Ørstüd"



"JOSÉ ØRSTÜD"





valid_character?(str)

Returns true if str is a single-character string containing a valid codepoint.



iex> String.valid_character? "∂"



true



iex> String.valid_character? "∂og"



false





Your Turn


Exercise: StringsAndBinaries-5

Write a function that takes a list of dqs and prints each on a separate line, centered in a column that has the width of the longest string. Make sure it works with UTF characters. iex> center(["cat", "zebra", "elephant"])



cat



zebra



elephant





Binaries and Pattern Matching


The first rule of binaries is “if in doubt, specify the type of each field.” Available types are binary, bits, bitstring, bytes, float, integer, utf8, utf16, and utf32. You can also add qualifiers:

size(n): The size in bits of the field.

signed or unsigned: For integer fields, should it be interpreted as signed?

endianness: big, little, or native.



Use hyphens to separate multiple attributes for a field:

<< length::unsigned-integer-size(12), flags::bitstring-size(4) >> = data





However, unless you’re doing a lot of work with binary file or protocol formats, the most common use of all this scary stuff is to process UTF-8 strings.





String Processing with Binaries


When we process lists, we use patterns that split the head from the rest of the list. With binaries that hold strings, we can do the same kind of trick. We have to specify the type of the head (UTF-8), and make sure the tail remains a binary.

strings/utf-iterate.ex

defmodule Utf8 do



def each(str, func) when is_binary(str), do: _each(str, func)





defp _each(<< head :: utf8, tail :: binary >>, func) do



func.(head)



_each(tail, func)



end





defp _each(<<>>, _func), do: []



end





Utf8.each "∂og", fn char -> IO.puts char end





produces:

8706



111



103





The parallels with list processing are clear, but the differences are significant. Rather than use [ head | tail ], we use << head::utf8, tail::binary >>. And rather than terminate when we reach the empty list, [], we look for an empty binary, <<>>.





Your Turn


Exercise: StringsAndBinaries-6

Write a function to capitalize the sentences in a string. Each sentence is terminated by a period and a space. Right now, the case of the characters in the string is random. iex> capitalize_sentences("oh. a DOG. woof. ")



"Oh. A dog. Woof. "





Exercise: StringsAndBinaries-7

Chapter 7, Lists and Recursion, had an exercise about calculating sales tax. We now have the sales information in a file of comma-separated id, ship_to, and amount values. The file looks like this: id,ship_to,net_amount



123,:NC,100.00



124,:OK,35.50



125,:TX,24.00



126,:TX,44.80



127,:NC,25.00



128,:MA,10.00



129,:CA,102.00



120,:NC,50.00





Write a function that reads and parses this file and then passes the result to the sales_tax function. Remember that the data should be formatted into a keyword list, and that the fields need to be the correct types (so the id field is an integer, and so on).

You’ll need the library functions File.open, IO.read(file, :line), and IO.stream(file).





Familiar Yet Strange


String handling in Elixir is the result of a long evolutionary process in the underlying Erlang environment. If we were starting from scratch, things would probably look a little different. But once you get over the slightly strange way that strings are matched using binaries, you’ll find that it works out well. In particular, pattern matching makes it very easy to look to strings that start with a particular sequence, which in turn makes simple parsing tasks a pleasure to write.

You may have noticed that we’re a long way into the book and haven’t yet talked about control-flow constructs such as if and case. This is deliberate: we use them less often in Elixir than in more conventional languages. However, we still need them, so they are the subject of the next chapter.



