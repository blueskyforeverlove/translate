## 第十一章 字符串和二进制

本章内容：

* String模块和字符串（string）
* 字符列表（character lists）
* 处理字符串和其模式匹配

我们一直很开心的用着字符串却没有专门讨论，现在是时候学习字符串了。

### 字符串定义

Elixir有两种字符表示：单引号和双引号包裹的字符。除了最本质的不同职务，其他还是有很多共同之处的。

字符串是由UTF-8编码的字符组成的。



| 1             | 2       | 3             |      4        |
|:-------------:|:-------:|:-------------:|:-------------:|
| BEL \a (0x07) | \b      | \BS(0x08)     | DEL \d (0x7f) |
| ESC \e (0x1b) | \f      | \FF(0x0c)     | NL \n (0x0a)  |
| CR  \r (0x0d) | \s      | \SP(0x20)     | TAB \t (0x09) |
| VT  \v (0x0b) | \xhhh     



它们都可以使用Elixir的格式化字符串的表达式`#{...}`语法：

```elixir
iex> name = "dave"
"dave"
iex> "Hello, #{String.capitalize name}!"
"Hello, Dave!"
```

有特殊含义的字符可以用反斜线转义。字符串还至此·heredocs·


### Heredocs

字符串可能是多行。为了说明这个现象，下面使用IO.puts 和IO.write两个函数。使用write来输出多行字符串，因为puts会自动换行。

```elixir
IO.puts "start"
IO.write "
my
string
"
IO.puts "end"
```
结果

```elixir
start

my
string
end
```

注意看多行的字符串，在打印之前，在两个输出字符串之间，puts函数多打印了一个空行。

`heredoc`将会修复整个问题。使用三个引号（''' 或者 """）可以去除你字符串里的缩进：

```elixir
IO.puts "start"
IO.write """
my
string
"""
IO.puts "end"
```

结果：

```elixir
start
my
string
end
```
Heredocs大量用于模块和函数编写文档的时候。



### 魔印（sigil）

与Ruby类似，Elixir对字符串简写的语法。使用`~r{...}`表示正则表达式。通常`~`定义的字符串字面量都可以称之为魔印（具有强大魔法的符号）。

魔印使用`~`符号开始，跟着一个大写或者小写的字母，然后界定内容，下面是一些用来做分界的可选符号：` <…>, {…}, […], (…), |…|, /…/, "…", 和 '…'`。

字母表示了魔印的类型：

| 字母   | 含义                    		                        |
|:-----:|:-----------------------------------------------------:|
| ~C 	 | 没有转义和计算格式化占位符的字符列表                        |
| ~c 	 | 有转义和计算格式化占位符的字符列表，等价于单引号引起来的字符    |
| ~R 	 | 没有有转义和计算格式化占位符的正则表达式                     |
| ~r 	 | 有转义和计算格式化占位符的正则表达式                        |
| ~S 	 | 没有转义和计算格式化占位符的字符串                          |
| ~s 	 | 有转义和计算格式化占位符的字符串，等价于双引号引起来的字符      |
| ~W 	 | 没有转义和计算格式化占位符的单词列表                         |
| ~w 	 | 有转义和计算格式化占位符的单词列表，等价于双引号引起来的字符      |


例如：

```elixir
iex> ~C[1\n2#{1+2}]   
'1\\n2\#{1+2}'			# 转义被忽略， {}占位符没有被求值计算
iex> ~c"1\n2#{1+2}"
'1\n23'					# 转义了，{}占位符被求值计算
iex> ~S[1\n2#{1+2}]
"1\\n2\#{1+2}"
iex> ~s/1\n2#{1+2}/
"1\n23"
iex> ~W[the c#{'a'}t sat on the mat]
["the", "c\#{'a'}t", "sat", "on", "the", "mat"]
iex> ~w[the c#{'a'}t sat on the mat]
["the", "cat", "sat", "on", "the", "mat"]
```

 ~W 和 ~w魔印最后可以使用可选的`a`, `c`或`s`修饰。分别用来修饰繁华原子，字符列表还是字符串。

```elixir
iex> ~w[the c#{'a'}t sat on the mat]a
[:the, :cat, :sat, :on, :the, :mat]
iex> ~w[the c#{'a'}t sat on the mat]c
['the', 'cat', 'sat', 'on', 'the', 'mat']
iex> ~w[the c#{'a'}t sat on the mat]s
["the", "cat", "sat", "on", "the", "mat"]
```

分隔符可以是任何非单词字符。成对的这些`(`, `[`, `{`, 或者 `<`都可以。

Elixir不会检查嵌套的分界符，例如`~s{a{b}`最终被识别为字符串`a{b`。

如果分界符是三引号开始的的，那么这个魔引会被当成是heredoc：

```elixir
iex> ~w"""
...> the
...> cat
...> sat
...> """

["the", "cat", "sat"]
```


如果想针对heredoc指定特别的魔印修饰（多数时候使用`~r`），可以在最后添加`i`。


If you want to specify modifiers with heredoc sigils (most commonly you’d do this with ~r), add them after the trailing delimiter.

```elixir
iex> ~r"""
...> hello
...> """i
~r/hello\n/i
```

魔印还有一个有趣的特性，那就是定制自己的魔印。再第三部分将会介绍。


###   “string”的含义 

Before we get further into this, I need to explain something. In most other languages, you’d call 'cat' and "cat" both strings. And that’s what I’ve been doing so far. But Elixir has a different convention.

In Elixir, the convention is that we call only double-quoted strings “strings.” The single-quoted form is a character list.

This is important. The single- and double-quoted forms are very different, and libraries that work on strings work only on the double-quoted form.

Let’s explore the differences in more detail.





Single-Quoted Strings—Lists of Character Codes


Single-quoted strings are represented as a list of integer values, each value corresponding to a codepoint in the string. For this reason, we refer to them as character lists (or char lists).

iex> str = 'wombat'



'wombat'



iex> is_list str



true



iex> length str



6



iex> Enum.reverse str



'tabmow'





This is confusing: iex says it is a list, but it shows the value as a string. That’s because iex prints a list of integers as a string if it believes each number in the list is a printable character. You can try this for yourself.

iex> [ 67, 65, 84 ]



'CAT'





You can look at the internal representation in a number of ways:

iex> str = 'wombat'



'wombat'



iex> :io.format "~w~n", [ str ]



[119,111,109,98,97,116]



:ok



iex> List.to_tuple str



{119, 111, 109, 98, 97, 116}



iex> str ++ [0]



[119, 111, 109, 98, 97, 116, 0]





The ~w in the format string forces str to be written as an Erlang term—the underlying list of integers. The ~n is a newline.

The last example creates a new character list with a null byte at the end. iex no longer thinks all the bytes are printable, and so returns the underlying character codes.

If a character list contains characters Erlang considers nonprintable, you’ll see the list representation.

iex> '∂x/∂y'



[8706, 120, 47, 8706, 121]





Because a character list is a list, we can use the usual pattern matching and List functions.

iex> 'pole' ++ 'vault'



'polevault'



iex> 'pole' -- 'vault'



'poe'



iex> List.zip [ 'abc', '123' ]



[{97, 49}, {98, 50}, {99, 51}]



iex> [ head | tail ] = 'cat'



'cat'



iex> head



99



iex> tail



'at'



iex> [ head | tail ]



'cat'





Why is the head of 'cat' 99 and not c?. Remember that a char list is just a list of integer character codes, so each individual entry is a number. It happens that 99 is the code for a lowercase c.

In fact, the notation ?c returns the integer code for the character c. This is often useful when employing patterns to extract information from character lists. Here’s a simple module that parses the character-list representation of an optionally signed decimal number.

strings/parse.exs

defmodule Parse do





def number([ ?- | tail ]), do: _number_digits(tail, 0) * -1



def number([ ?+ | tail ]), do: _number_digits(tail, 0)



def number(str), do: _number_digits(str, 0)





defp _number_digits([], value), do: value



defp _number_digits([ digit | tail ], value)



when digit in '0123456789' do



_number_digits(tail, value*10 + digit - ?0)



end



defp _number_digits([ non_digit | _ ], _) do



raise "Invalid digit '#{[non_digit]}'"



end



end





Let’s try it in iex.

iex> c("parse.exs")



[Parse]



iex> Parse.number('123')



123



iex> Parse.number('-123')



-123



iex> Parse.number('+123')



123



iex> Parse.number('+9')



9



iex> Parse.number('+a')



** (RuntimeError) Invalid digit 'a'





Your Turn


Exercise: StringsAndBinaries-1

Write a function that returns true if a single-quoted string contains only printable ASCII characters (space through tilde).



Exercise: StringsAndBinaries-2

Write an anagram?(word1, word2) that returns true if its parameters are anagrams.



Exercise: StringsAndBinaries-3

Try the following in iex: iex> [ 'cat' | 'dog' ]



['cat',100,111,103]





Why does iex print 'cat' as a string, but 'dog' as individual numbers?



Exercise: StringsAndBinaries-4

(Hard) Write a function that takes a single-quoted string of the form number [+-*/] number and returns the result of the calculation. The individual numbers do not have leading plus or minus signs.

calculate('123 + 27') # => 150





Binaries


The binary type represents a sequence of bits.

A binary literal looks like << term,… >>.

The simplest term is just a number from 0 to 255. The numbers are stored as successive bytes in the binary.

iex> b = << 1, 2, 3 >>



<<1, 2, 3>>



iex> byte_size b



3



iex> bit_size b



24





You can specify modifiers to set any term’s size (in bits). This is useful when working with binary formats such as media files and network packets.

iex> b = << 1::size(2), 1::size(3) >>



<<9::size(5)>>



iex> byte_size b



1



iex> bit_size b



5





You can store integers, floats, and other binaries in binaries.

iex> int = << 1 >>



<<1>>



iex> float = << 2.5 :: float >>



<<64, 4, 0, 0, 0, 0, 0, 0>>



iex> mix = << int :: binary, float :: binary >>



<<1, 64, 4, 0, 0, 0, 0, 0, 0>>





Let’s finish an initial look at binaries with an example of bit extraction. An IEEE 754 float has a sign bit, 11 bits of exponent, and 52 bits of mantissa. The exponent is biased by 1023, and the mantissa is a fraction with the top bit assumed to be 1. So we can extract the fields and then use :math.pow, which performs exponentiation, to reassemble the number:

iex> << sign::size(1), exp::size(11), mantissa::size(52) >> = << 3.14159::float >>



iex> (1 + mantissa / :math.pow(2, 52)) * :math.pow(2, exp-1023)



3.14159





Double-Quoted Strings Are Binaries


Whereas single-quoted strings are stored as char lists, the contents of a double-quoted string (dqs) are stored as a consecutive sequence of bytes in UTF-8 encoding. Clearly this is more efficient in terms of memory and certain forms of access, but it does have two implications.

First, because UTF-8 characters can take more than a single byte to represent, the size of the binary is not necessarily the length of the string.

iex> dqs = "∂x/∂y"



"∂x/∂y"



iex> String.length dqs



5



iex> byte_size dqs



9



iex> String.at(dqs, 0)



"∂"



iex> String.codepoints(dqs)



["∂", "x", "/", "∂", "y"]



iex> String.split(dqs, "/")



["∂x", "∂y"]





Second, because you’re no longer using lists, you need to learn and work with the binary syntax alongside the list syntax in your code.





Strings and Elixir Libraries


When Elixir library documentation uses the word string (and most of the time it uses the word binary), it means double-quoted strings.

The String module defines a number of functions that work with double-quoted strings.

at(str, offset)

Returns the grapheme at the given offset (starting at 0). Negative offsets count from the end of the string.



iex> String.at("∂og", 0)



"∂"



iex> String.at("∂og", -1)



"g"





capitalize(str)

Converts str to lowercase, and then capitalizes the first character.



iex> String.capitalize "école"



"École"



iex> String.capitalize "ÎÎÎÎÎ"



"Îîîîî"





codepoints(str)

Returns the codepoints in str.



iex> String.codepoints("José's ∂øg")



["J", "o", "s", "é", "'", "s", " ", "∂", "ø", "g"]





downcase(str)

Converts str to lowercase.



iex> String.downcase "ØRSteD"



"ørsted"





duplicate(str, n)

Returns a string containing n copies of str.



iex> String.duplicate "Ho! ", 3



"Ho! Ho! Ho! "





ends_with?(str, suffix | [ suffixes ])

True if str ends with any of the given suffixes.



iex> String.ends_with? "string", ["elix", "stri", "ring"]



true





first(str)

Returns the first grapheme from str.



iex> String.first "∂og"



"∂"





graphemes(str)

Returns the graphemes in the string. This is different from the codepoints function, which lists combining characters separately.



last(str)

Returns the last grapheme from str.



iex> String.last "∂og"



"g"





length(str)

Returns the number of graphemes in str.



iex> String.length "∂x/∂y"



5





ljust(str, new_length, padding \\ " ")

Returns a new string, at least new_length characters long, containing str left-justified and padded with padding.



iex> String.ljust("cat", 5)



"cat "





lstrip(str)

Removes leading whitespace from str.



iex> String.lstrip "\t\f Hello\t\n"



"Hello\t\n"





lstrip(str, character)

Removes leading copies of character (an integer codepoint) from str.



iex> String.lstrip "!!!SALE!!!", ?!



"SALE!!!"





next_codepoint(str)

Splits str into its leading codepoint and the rest, or nil if str is empty. This may be used as the basis of an iterator.



strings/nextcodepoint.ex

defmodule MyString do



def each(str, func), do: _each(String.next_codepoint(str), func)





defp _each({codepoint, rest}, func) do



func.(codepoint)



_each(String.next_codepoint(rest), func)



end





defp _each(nil, _), do: []



end





MyString.each "∂og", fn c -> IO.puts c end





produces:

∂



o



g





next_grapheme(str)

Same as next_codepoint, but returns graphemes (and :no_grapheme on completion).



printable?(str)

Returns true if str contains only printable characters.



iex> String.printable? "José"



true



iex> String.printable? "\x{0000} a null"



false





replace(str, pattern, replacement, options \\ [global: true, insert_replaced: nil])

Replaces pattern with replacement in str under control of options.



If the :global option is true, all occurrences of the pattern are replaced; otherwise only the first is replaced.



If :insert_replaced is set to a number, the pattern is inserted into the replacement at that offset. If the option is a list, it is inserted multiple times.



iex> String.replace "the cat on the mat", "at", "AT"



"the cAT on the mAT"



iex> String.replace "the cat on the mat", "at", "AT", global: false



"the cAT on the mat"



iex> String.replace "the cat on the mat", "at", "AT", insert_replaced: 0



"the catAT on the matAT"



iex> String.replace "the cat on the mat", "at", "AT", insert_replaced: [0,2]



"the catATat on the matATat"





reverse(str)

Reverses the graphemes in a string.



iex> String.reverse "pupils"



"slipup"



iex> String.reverse "∑ƒ÷∂"



"∂÷ƒ∑"





rjust(str, new_length, padding \\ " ")

Returns a new string, at least new_length characters long, containing str right-justified and padded with padding.



iex> String.rjust("cat", 5, ?>)



">>cat"





rstrip(str)

Removes trailing whitespace from str.



iex> String.rstrip(" line \r\n")



" line"





rstrip(str, character)

Removes trailing occurrences of character from str.



iex> String.rstrip "!!!SALE!!!", ?!



"!!!SALE"





slice(str, offset, len)

Returns a len character substring starting at offset (measured from the end of str if negative).



iex> String.slice "the cat on the mat", 4, 3



"cat"



iex> String.slice "the cat on the mat", -3, 3



"mat"





split(str, pattern \\ nil, options \\ [global: true])

Splits str into substrings delimited by pattern. If :global is false, only one split is performed. pattern can be a string, a regular expression, or nil. In the latter case, the string is split on whitespace.



iex> String.split " the cat on the mat "



["the", "cat", "on", "the", "mat"]



iex> String.split "the cat on the mat", "t"



["", "he ca", " on ", "he ma", ""]



iex> String.split "the cat on the mat", ~r{[ae]}



["th", " c", "t on th", " m", "t"]



iex> String.split "the cat on the mat", ~r{[ae]}, parts: 2



["th", " cat on the mat"]





starts_with?(str, prefix | [ prefixes ])

True if str starts with any of the given prefixes.



iex> String.starts_with? "string", ["elix", "stri", "ring"]



true





strip(str)

Strips leading and trailing whitespace from str.



iex> String.strip "\t Hello \r\n"



"Hello"





strip(str, character)

Strips leading and trailing instances of character from str.



iex> String.strip "!!!SALE!!!", ?!



"SALE"





upcase(str)

Returns an uppercase version of str.



iex> String.upcase "José Ørstüd"



"JOSÉ ØRSTÜD"





valid_character?(str)

Returns true if str is a single-character string containing a valid codepoint.



iex> String.valid_character? "∂"



true



iex> String.valid_character? "∂og"



false





Your Turn


Exercise: StringsAndBinaries-5

Write a function that takes a list of dqs and prints each on a separate line, centered in a column that has the width of the longest string. Make sure it works with UTF characters. iex> center(["cat", "zebra", "elephant"])



cat



zebra



elephant





Binaries and Pattern Matching


The first rule of binaries is “if in doubt, specify the type of each field.” Available types are binary, bits, bitstring, bytes, float, integer, utf8, utf16, and utf32. You can also add qualifiers:

size(n): The size in bits of the field.

signed or unsigned: For integer fields, should it be interpreted as signed?

endianness: big, little, or native.



Use hyphens to separate multiple attributes for a field:

<< length::unsigned-integer-size(12), flags::bitstring-size(4) >> = data





However, unless you’re doing a lot of work with binary file or protocol formats, the most common use of all this scary stuff is to process UTF-8 strings.





String Processing with Binaries


When we process lists, we use patterns that split the head from the rest of the list. With binaries that hold strings, we can do the same kind of trick. We have to specify the type of the head (UTF-8), and make sure the tail remains a binary.

strings/utf-iterate.ex

defmodule Utf8 do



def each(str, func) when is_binary(str), do: _each(str, func)





defp _each(<< head :: utf8, tail :: binary >>, func) do



func.(head)



_each(tail, func)



end





defp _each(<<>>, _func), do: []



end





Utf8.each "∂og", fn char -> IO.puts char end





produces:

8706



111



103





The parallels with list processing are clear, but the differences are significant. Rather than use [ head | tail ], we use << head::utf8, tail::binary >>. And rather than terminate when we reach the empty list, [], we look for an empty binary, <<>>.





Your Turn


Exercise: StringsAndBinaries-6

Write a function to capitalize the sentences in a string. Each sentence is terminated by a period and a space. Right now, the case of the characters in the string is random. iex> capitalize_sentences("oh. a DOG. woof. ")



"Oh. A dog. Woof. "





Exercise: StringsAndBinaries-7

Chapter 7, Lists and Recursion, had an exercise about calculating sales tax. We now have the sales information in a file of comma-separated id, ship_to, and amount values. The file looks like this: id,ship_to,net_amount



123,:NC,100.00



124,:OK,35.50



125,:TX,24.00



126,:TX,44.80



127,:NC,25.00



128,:MA,10.00



129,:CA,102.00



120,:NC,50.00





Write a function that reads and parses this file and then passes the result to the sales_tax function. Remember that the data should be formatted into a keyword list, and that the fields need to be the correct types (so the id field is an integer, and so on).

You’ll need the library functions File.open, IO.read(file, :line), and IO.stream(file).





Familiar Yet Strange


String handling in Elixir is the result of a long evolutionary process in the underlying Erlang environment. If we were starting from scratch, things would probably look a little different. But once you get over the slightly strange way that strings are matched using binaries, you’ll find that it works out well. In particular, pattern matching makes it very easy to look to strings that start with a particular sequence, which in turn makes simple parsing tasks a pleasure to write.

You may have noticed that we’re a long way into the book and haven’t yet talked about control-flow constructs such as if and case. This is deliberate: we use them less often in Elixir than in more conventional languages. However, we still need them, so they are the subject of the next chapter.



