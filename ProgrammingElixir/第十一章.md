## 第十一章 字符串和二进制

本章内容：

* String模块和字符串（string）
* 字符列表（character lists）
* 处理字符串和其模式匹配

我们一直很开心的用着字符串却没有专门讨论，现在是时候学习字符串了。

### 字符串定义

Elixir有两种字符表示：单引号和双引号包裹的字符。除了最本质的不同职务，其他还是有很多共同之处的。

字符串是由UTF-8编码的字符组成的。



| 1             | 2       | 3             |      4        |
|:-------------:|:-------:|:-------------:|:-------------:|
| BEL \a (0x07) | \b      | \BS(0x08)     | DEL \d (0x7f) |
| ESC \e (0x1b) | \f      | \FF(0x0c)     | NL \n (0x0a)  |
| CR  \r (0x0d) | \s      | \SP(0x20)     | TAB \t (0x09) |
| VT  \v (0x0b) | \xhhh     



它们都可以使用Elixir的格式化字符串的表达式`#{...}`语法：

```elixir
iex> name = "dave"
"dave"
iex> "Hello, #{String.capitalize name}!"
"Hello, Dave!"
```

有特殊含义的字符可以用反斜线转义。字符串还至此·heredocs·


### Heredocs

字符串可能是多行。为了说明这个现象，下面使用IO.puts 和IO.write两个函数。使用write来输出多行字符串，因为puts会自动换行。

```elixir
IO.puts "start"
IO.write "
my
string
"
IO.puts "end"
```
结果

```elixir
start

my
string
end
```

注意看多行的字符串，在打印之前，在两个输出字符串之间，puts函数多打印了一个空行。

`heredoc`将会修复整个问题。使用三个引号（''' 或者 """）可以去除你字符串里的缩进：

```elixir
IO.puts "start"
IO.write """
my
string
"""
IO.puts "end"
```

结果：

```elixir
start
my
string
end
```
Heredocs大量用于模块和函数编写文档的时候。



### 魔印（sigil）

与Ruby类似，Elixir对字符串简写的语法。使用`~r{...}`表示正则表达式。通常`~`定义的字符串字面量都可以称之为魔印（具有强大魔法的符号）。

魔印使用`~`符号开始，跟着一个大写或者小写的字母，然后界定内容，下面是一些用来做分界的可选符号：` <…>, {…}, […], (…), |…|, /…/, "…", 和 '…'`。

字母表示了魔印的类型：

| 字母   | 含义                    		                        |
|:-----:|:-----------------------------------------------------:|
| ~C 	 | 没有转义和计算格式化占位符的字符列表                        |
| ~c 	 | 有转义和计算格式化占位符的字符列表，等价于单引号引起来的字符    |
| ~R 	 | 没有有转义和计算格式化占位符的正则表达式                     |
| ~r 	 | 有转义和计算格式化占位符的正则表达式                        |
| ~S 	 | 没有转义和计算格式化占位符的字符串                          |
| ~s 	 | 有转义和计算格式化占位符的字符串，等价于双引号引起来的字符      |
| ~W 	 | 没有转义和计算格式化占位符的单词列表                         |
| ~w 	 | 有转义和计算格式化占位符的单词列表，等价于双引号引起来的字符      |


例如：

```elixir
iex> ~C[1\n2#{1+2}]   
'1\\n2\#{1+2}'			# 转义被忽略， {}占位符没有被求值计算
iex> ~c"1\n2#{1+2}"
'1\n23'					# 转义了，{}占位符被求值计算
iex> ~S[1\n2#{1+2}]
"1\\n2\#{1+2}"
iex> ~s/1\n2#{1+2}/
"1\n23"
iex> ~W[the c#{'a'}t sat on the mat]
["the", "c\#{'a'}t", "sat", "on", "the", "mat"]
iex> ~w[the c#{'a'}t sat on the mat]
["the", "cat", "sat", "on", "the", "mat"]
```

 ~W 和 ~w魔印最后可以使用可选的`a`, `c`或`s`修饰。分别用来修饰繁华原子，字符列表还是字符串。

```elixir
iex> ~w[the c#{'a'}t sat on the mat]a
[:the, :cat, :sat, :on, :the, :mat]
iex> ~w[the c#{'a'}t sat on the mat]c
['the', 'cat', 'sat', 'on', 'the', 'mat']
iex> ~w[the c#{'a'}t sat on the mat]s
["the", "cat", "sat", "on", "the", "mat"]
```

分隔符可以是任何非单词字符。成对的这些`(`, `[`, `{`, 或者 `<`都可以。

Elixir不会检查嵌套的分界符，例如`~s{a{b}`最终被识别为字符串`a{b`。

如果分界符是三引号开始的的，那么这个魔引会被当成是heredoc：

```elixir
iex> ~w"""
...> the
...> cat
...> sat
...> """

["the", "cat", "sat"]
```


如果想针对heredoc指定特别的魔印修饰（多数时候使用`~r`），可以在最后添加`i`。


If you want to specify modifiers with heredoc sigils (most commonly you’d do this with ~r), add them after the trailing delimiter.

```elixir
iex> ~r"""
...> hello
...> """i
~r/hello\n/i
```

魔印还有一个有趣的特性，那就是定制自己的魔印。再第三部分将会介绍。


###   “string”的含义 


在我们继续学习之前，还有一些东西需要解释。大多数编程语言中，'cat'和"cat"都是字符串。到目前为止也是如此但是，Elixir中他们的表示含义却不尽相同。

Elixir中，字符串指使用双引号包裹的字符。单引号包裹的则是字符列表。

这十分重要，单引号和双引号的形式不一样，并且字符串的类库只适用于双引号的形式。

现在我们来探讨不同的细节部分。


### 单引号字串其实是字符列表。

字符列表实际上是一串整数的列表，每一项的值是对于字符的码值。因此，我们可以把字符列表当成列表来使用：

```elixir
iex> str = 'wombat'
'wombat'
iex> is_list str
true
iex> length str
6
iex> Enum.reverse str
'tabmow'
```

这有点让人疑惑，iex说它使列表，显示的却是字符。因为如果某个码值是可以打印的，那就iex就打印该码值对应的字符。你可以自己尝试：

```elixir
iex> [ 67, 65, 84 ]
'CAT'
```

通过下面的方法查看字符列表的原始码值：

```elixir
iex> str = 'wombat'
'wombat'
iex> :io.format "~w~n", [ str ]
[119,111,109,98,97,116]
:ok
iex> List.to_tuple str
{119, 111, 109, 98, 97, 116}
iex> str ++ [0]
[119, 111, 109, 98, 97, 116, 0]
```

`~w`借助Erlang虚拟机强制把所代表的字符格式化成码值列表。`~n`表示换行。


最后一个例子给字符列表的末尾追加一个空字节的列表。此时iex不再认为所有的码值都是可打印的了，因此就返回了字符的码值。

字符列表包含了Erlang中不能打印的码值，你会看到对应的列表：

```elixir
iex> '∂x/∂y'
[8706, 120, 47, 8706, 121]
```
因为字符列表也是列表，因此我们可以使用列表函数和模式匹配。

```elixir
iex> 'pole' ++ 'vault'
'polevault'
iex> 'pole' -- 'vault'
'poe'
iex> List.zip [ 'abc', '123' ]
[{97, 49}, {98, 50}, {99, 51}]
iex> [ head | tail ] = 'cat'
'cat'
iex> head
99
iex> tail
'at'
iex> [ head | tail ]
'cat'
```

为什么字符列表`'cat'`的头部是`99`而不是`c`呢？记住了，字符列表是字符的码值组成的，因此每一个列表项就是一个整数。因此头部`c`就是`c`的码值`99`。

可以使用`?`操作符获取一个字符的码值，`?c`返回`c`的码值。当从字符列表中分解进行模式匹配的时候这个技巧将会很有用。下面的模块实现了一个字符列表转换码值的功能。

strings/parse.exs

```elixir
defmodule Parse do

	def number([ ?- | tail ]), do: _number_digits(tail, 0) * -1

	def number([ ?+ | tail ]), do: _number_digits(tail, 0)

	def number(str), do: _number_digits(str, 0)

	defp _number_digits([], value), do: value

	defp _number_digits([ digit | tail ], value) when digit in '0123456789' do
		_number_digits(tail, value*10 + digit - ?0)
	end

	defp _number_digits([ non_digit | _ ], _) do
		raise "Invalid digit '#{[non_digit]}'"
	end
end
```


Let’s try it in iex.

```elixir
iex> c("parse.exs")
[Parse]
iex> Parse.number('123')
123
iex> Parse.number('-123')
-123
iex> Parse.number('+123')
123
iex> Parse.number('+9')
9
iex> Parse.number('+a')
** (RuntimeError) Invalid digit 'a'
```

### 二进制（Binaries）


二进制类型是位的序列。使用`<<>>`定义字面量。大致如 `<< 项,… >>`，最简单项是0~255的整数。这些数字是存储在二进制中的连续字节。

```elixir
iex> b = << 1, 2, 3 >>
<<1, 2, 3>>
iex> byte_size b
3
iex> bit_size b
24
```

当然，你也可定制项的大小（使用位(bit)单位）。这个技巧在使用二进制格式化一些媒体文件和网络数据包的时候很有用。

```elixir
iex> b = << 1::size(2), 1::size(3) >>
<<9::size(5)>>
iex> byte_size b
1
iex> bit_size b
5
```

也可以存储整数，浮点数或者其他二进制类型。


```elixir
iex> int = << 1 >>
<<1>>
iex> float = << 2.5 :: float >>
<<64, 4, 0, 0, 0, 0, 0, 0>>
iex> mix = << int :: binary, float :: binary >>
<<1, 64, 4, 0, 0, 0, 0, 0, 0>>
```

让我们来看一个二进制位提取的一个例子。[`IEEE 754`协议](http://zh.wikipedia.org/zh/IEEE_754)规定了浮点数有一个位符号（sign）和11位的指数（exponent）已经52为的尾数（mantissa）。下面是一个浮点数转换成二进制的例子：


```elixir
iex> << sign::size(1), exp::size(11), mantissa::size(52) >> = << 3.14159::float >>
iex> (1 + mantissa / :math.pow(2, 52)) * :math.pow(2, exp-1023)
3.14159
```


### 双引号字符串本质是二进制（Binaries）


单引号定义的字符是字符列表，双引号表示的是用UTF-8编码的连续序列。显然，访问这样的形式在内存方面要更高效，但是这有两层含义。

首先，UTF-8编码表示一个字符并不都是使用一个字节，因此字节的长度和字符串的长度是不一样的。

```elixir
iex> dqs = "∂x/∂y"
"∂x/∂y"
iex> String.length dqs
5
iex> byte_size dqs
9
iex> String.at(dqs, 0)
"∂"
iex> String.codepoints(dqs)
["∂", "x", "/", "∂", "y"]
iex> String.split(dqs, "/")
["∂x", "∂y"]
```

其次，当你不再使用列表的时候，你需要学会二进制语法和列表语法。

### 字符串和Elixir库

Elixir的文档使用单词**字符串**（通常还是习惯使用单词**二进制**）。
表示双引号的字符串/

When Elixir library documentation uses the word string (and most of the time it uses the word binary), it means double-quoted strings.

String模块提供了一些函数用于处理字符串。

* at(str, offset)

返回字符串在给定的偏移（offset），offset为负数的时候，表示从字符的末端开始计数。

```elixir
iex> String.at("∂og", 0)
"∂"
iex> String.at("∂og", -1)
"g"
```

* capitalize(str)

先字符串转换成小写，然后让首字母大写。

```elixir
iex> String.capitalize "école"
"École"
iex> String.capitalize "ÎÎÎÎÎ"
"Îîîîî"
```

* codepoints(str)

返回字符串的码值列表，拆分字符串


```elixir
iex> String.codepoints("José's ∂øg")
["J", "o", "s", "é", "'", "s", " ", "∂", "ø", "g"]
```

* downcase(str)

把字符串转成小写

```elixir
iex> String.downcase "ØRSteD"
"ørsted"
```

* duplicate(str, n)

返回字符串重复的叠加

```elixir
iex> String.duplicate "Ho! ", 3
"Ho! Ho! Ho! "
```

* ends_with?(str, suffix | [ suffixes ])

如果`str`的结尾与`suffixes`中任何一个匹配，则返回`true`

```elixir
iex> String.ends_with? "string", ["elix", "stri", "ring"]
true
```


* first(str)

返回字符串首字母

```elixir
iex> String.first "∂og"
"∂"
```

* graphemes(str)

返回字符串的字形（graphemes）。字形和码值函数不一样，它分别列出组合的字符，即字符本身。

* last(str)

返回最后一个字形（字形就是指字符串看上去的样子）

```elixir
iex> String.last "∂og"
"g"
```
length(str)

返回字符串字形的长度

```elixir
iex> String.length "∂x/∂y"
5
```




ljust(str, new_length, padding \\ " ")

Returns a new string, at least new_length characters long, containing str left-justified and padded with padding.


```elixir
iex> String.ljust("cat", 5)
"cat "
```


lstrip(str)

Removes leading whitespace from str.


```elixir
iex> String.lstrip "\t\f Hello\t\n"
"Hello\t\n"
```




lstrip(str, character)

Removes leading copies of character (an integer codepoint) from str.


```elixir
iex> String.lstrip "!!!SALE!!!", ?!
"SALE!!!"
```

next_codepoint(str)

Splits str into its leading codepoint and the rest, or nil if str is empty. This may be used as the basis of an iterator.



strings/nextcodepoint.ex
```elixir
defmodule MyString do

	def each(str, func), do: _each(String.next_codepoint(str), func)

	defp _each({codepoint, rest}, func) do

		func.(codepoint)

		_each(String.next_codepoint(rest), func)

	end

	defp _each(nil, _), do: []

end

MyString.each "∂og", fn c -> IO.puts c end
```

produces:

```elixir
∂
o
g
```




next_grapheme(str)

Same as next_codepoint, but returns graphemes (and :no_grapheme on completion).



printable?(str)

Returns true if str contains only printable characters.


```elixir
iex> String.printable? "José"
true
iex> String.printable? "\x{0000} a null"
false
```

replace(str, pattern, replacement, options \\ [global: true, insert_replaced: nil])

Replaces pattern with replacement in str under control of options.



If the :global option is true, all occurrences of the pattern are replaced; otherwise only the first is replaced.



If :insert_replaced is set to a number, the pattern is inserted into the replacement at that offset. If the option is a list, it is inserted multiple times.


```elixir
iex> String.replace "the cat on the mat", "at", "AT"
"the cAT on the mAT"
iex> String.replace "the cat on the mat", "at", "AT", global: false
"the cAT on the mat"
iex> String.replace "the cat on the mat", "at", "AT", insert_replaced: 0
"the catAT on the matAT"
iex> String.replace "the cat on the mat", "at", "AT", insert_replaced: [0,2]
"the catATat on the matATat"
```


reverse(str)

Reverses the graphemes in a string.

```elixir
iex> String.reverse "pupils"
"slipup"
iex> String.reverse "∑ƒ÷∂"
"∂÷ƒ∑"
```

rjust(str, new_length, padding \\ " ")

Returns a new string, at least new_length characters long, containing str right-justified and padded with padding.


```elixir
iex> String.rjust("cat", 5, ?>)
">>cat"
```


rstrip(str)

Removes trailing whitespace from str.

```elixir
iex> String.rstrip(" line \r\n")
" line"
```




rstrip(str, character)

Removes trailing occurrences of character from str.


```elixir
iex> String.rstrip "!!!SALE!!!", ?!
"!!!SALE"
```

slice(str, offset, len)

Returns a len character substring starting at offset (measured from the end of str if negative).


```elixir
iex> String.slice "the cat on the mat", 4, 3
"cat"
iex> String.slice "the cat on the mat", -3, 3
"mat"
```




split(str, pattern \\ nil, options \\ [global: true])

Splits str into substrings delimited by pattern. If :global is false, only one split is performed. pattern can be a string, a regular expression, or nil. In the latter case, the string is split on whitespace.


```elixir
iex> String.split " the cat on the mat "
["the", "cat", "on", "the", "mat"]
iex> String.split "the cat on the mat", "t"
["", "he ca", " on ", "he ma", ""]
iex> String.split "the cat on the mat", ~r{[ae]}
["th", " c", "t on th", " m", "t"]
iex> String.split "the cat on the mat", ~r{[ae]}, parts: 2
["th", " cat on the mat"]
starts_with?(str, prefix | [ prefixes ])
```

True if str starts with any of the given prefixes.


```elixir
iex> String.starts_with? "string", ["elix", "stri", "ring"]
true
```

strip(str)

Strips leading and trailing whitespace from str.


```elixir
iex> String.strip "\t Hello \r\n"
"Hello"
```




strip(str, character)

Strips leading and trailing instances of character from str.

```elixir
iex> String.strip "!!!SALE!!!", ?!
"SALE"
```

upcase(str)


Returns an uppercase version of str.

```elixir
iex> String.upcase "José Ørstüd"
"JOSÉ ØRSTÜD"
```

valid_character?(str)

Returns true if str is a single-character string containing a valid codepoint.
```elixir
iex> String.valid_character? "∂"
true
iex> String.valid_character? "∂og"
false
```


### 二进制和模式匹配


The first rule of binaries is “if in doubt, specify the type of each field.” Available types are binary, bits, bitstring, bytes, float, integer, utf8, utf16, and utf32. You can also add qualifiers:

size(n): The size in bits of the field.

signed or unsigned: For integer fields, should it be interpreted as signed?

endianness: big, little, or native.



Use hyphens to separate multiple attributes for a field:

<< length::unsigned-integer-size(12), flags::bitstring-size(4) >> = data



However, unless you’re doing a lot of work with binary file or protocol formats, the most common use of all this scary stuff is to process UTF-8 strings.


### 使用二进制处理字符串

When we process lists, we use patterns that split the head from the rest of the list. With binaries that hold strings, we can do the same kind of trick. We have to specify the type of the head (UTF-8), and make sure the tail remains a binary.

strings/utf-iterate.ex

```elixir
defmodule Utf8 do

	def each(str, func) when is_binary(str), do: _each(str, func)

	defp _each(<< head :: utf8, tail :: binary >>, func) do

		func.(head)
		_each(tail, func)

	end

	defp _each(<<>>, _func), do: []

end
Utf8.each "∂og", fn char -> IO.puts char end
```

produces:

```elixir
8706
111
103
```

The parallels with list processing are clear, but the differences are significant. Rather than use [ head | tail ], we use << head::utf8, tail::binary >>. And rather than terminate when we reach the empty list, [], we look for an empty binary, <<>>.



Familiar Yet Strange


String handling in Elixir is the result of a long evolutionary process in the underlying Erlang environment. If we were starting from scratch, things would probably look a little different. But once you get over the slightly strange way that strings are matched using binaries, you’ll find that it works out well. In particular, pattern matching makes it very easy to look to strings that start with a particular sequence, which in turn makes simple parsing tasks a pleasure to write.

You may have noticed that we’re a long way into the book and haven’t yet talked about control-flow constructs such as if and case. This is deliberate: we use them less often in Elixir than in more conventional languages. However, we still need them, so they are the subject of the next chapter.



