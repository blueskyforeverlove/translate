

Chapter 6





Modules and Named Functions




* * *



In this chapter, we’ll see

Modules, the basic unit of code

Defining public and private named functions

Guard clauses

Module directives and attributes

Calling functions in Erlang modules



Once a program grows beyond a couple of lines, you’ll want to structure it. Elixir makes this easy. You break your code into named functions and organize these functions into modules. In fact, in Elixir named functions must be written inside modules.

Let’s look at a simple example. Navigate to a working directory and create an Elixir source file called times.exs.

mm/times.exs

defmodule Times do



def double(n) do



n * 2



end



end





Here we have a module named Times. It contains a single function, double. Because our function takes a single argument and because the number of arguments forms part of the way we identify Elixir functions, you’ll see this function name written double/1.





Compiling a Module


Let’s look at two ways to compile this file and load it into iex. First, if you’re at the command line, you can do this:

$ iex times.exs



iex> Times.double 4



8





Give iex a source file’s name, and it compiles and loads the file before it displays a prompt.

If you’re already in iex, you can use the c helper to compile your file without returning to the command line.

iex> c "times.exs"



[Times]



iex> Times.double(4)



8



iex> Times.double(123)



246





The line c "times.exs" compiles your source file and loads it into iex. We then call the double function in the Times module a couple of times using Times.double.

What happens if we make our function fail by passing it a string rather than a number?

iex> Times.double("cat")



** (ArithmeticError) bad argument in arithmetic expression



times.exs:3: Times.double/1





An exception (ArithmeticError) gets raised, and we see a stack backtrace. The first line tells us what went wrong (we tried to perform arithmetic on a string), and the next line tells us where. But look at what it writes for the name of our function: Times.double/1.

In Elixir a named function is identified by both its name and its number of parameters (its arity). Our double function takes one parameter, so Elixir knows it as double/1. If we had another version of double that took three parameters, it would be known as double/3. These two functions are totally separate as far as Elixir is concerned. But from a human perspective, you’d imagine that if two functions have the same name they are somehow related, even if they have a different number of parameters. For that reason, don’t use the same name for two functions that do unrelated things.





The Function’s Body Is a Block


The do…end block is one way of grouping expressions and passing them to other code. They are used in module and named function definitions, control structures…any place in Elixir where code needs to be handled as an entity.

However, do…end is not actually the underlying syntax. The actual syntax looks like this:

def double(n), do: n * 2





You can pass multiple lines to do: by grouping them with parentheses.

def greet(greeting, name), do: (



IO.puts greeting



IO.puts "How're you doing, #{name}?"



)





The do…end form is just a lump of syntactic sugar—during compilation it is turned into the do: form. (And the do: form itself is nothing special; it is simply a term in a keyword list.) Typically people use the do: syntax for single-line blocks, and do…end for multiline ones.

This means our times example would probably be written as

mm/times1.exs

defmodule Times do



def double(n), do: n * 2



end





We could even write it as

defmodule Times, do: (def double(n), do: n*2)





(but please don’t).





Your Turn


Exercise: ModulesAndFunctions-1

Extend the Times module with a triple function that multiplies its parameter by three.



Exercise: ModulesAndFunctions-2

Run the result in iex. Use both techniques to compile the file.



Exercise: ModulesAndFunctions-3

Add a quadruple function. (Maybe it could call the double function.…)





Function Calls and Pattern Matching


In the previous chapter we covered how anonymous functions use pattern matching to bind their parameter list to the passed arguments. The same is true of named functions. The difference is that we write the function multiple times, each time with its own parameter list and body. Although this looks like multiple function definitions, purists will tell you it’s multiple clauses of the same definition (and they’d be right).

When you call a named function, Elixir tries to match your arguments with the parameter list of the first definition (clause). If it cannot match them, it tries the next definition of the same function (remember, this must have the same arity) and checks to see if it matches. It continues until it runs out of candidates.

Let’s play with this. The factorial of n (written n!) is the product of all numbers from 1 to n. By convention, 0! is 1.

Another way of expressing this is to say

factorial(0) → 1

factorial(n) → n * factorial(n-1)



This is a specification of factorial, but it is also very close to an Elixir implementation:

mm/factorial1.exs

defmodule Factorial do



def of(0), do: 1



def of(n), do: n * of(n-1)



end





Here we have two definitions of the same function. If we call Factorial.of(2), Elixir matches the 2 against the first function’s parameter, 0. This fails, so it tries the second definition, which succeeds when Elixir binds 2 to n. It then evaluates the body of this function, which calls Factorial.of(1). The same process applies, and the second definition is run. This, in turn, calls Factorial.of(0), which is matched by the first function definition. This function returns 1 and the recursion ends. Elixir now unwinds the stack, performing all the multiplications, and returns the answer. This factorial implementation works, but it could be significantly improved. We’ll do that improvement when we look at tail recursion.

Let’s play with this code:

iex> c "factorial1.exs"



[Factorial]



iex> Factorial.of(3)



6



iex> Factorial.of(7)



5040



iex> Factorial.of(10)



3628800



iex> Factorial.of(1000)



40238726007709377354370243392300398571937486421071463254379991042993851239862



90205920442084869694048004799886101971960586316668729948085589013238296699445



...



00624271243416909004153690105933983835777939410970027753472000000000000000000



00000000000000000000000000000000000000000000000000000000000000000000000000000



00000000000000000000000000000000000000000000000000000000000000000000000000000



00000000000000000000000000000000000000000000000000000000000000000000000000000





This pattern of design and coding is very common in Elixir (and almost all functional languages). First look for the simplest possible case, one that has a definite answer. This will be the anchor. Then look for a recursive solution that will end up calling the anchor case.

Here are a couple of examples:

Sum of the first n numbers

The sum of the first 0 numbers is 0.

The sum of the numbers up to n is n + the sum of the numbers up to n–1.



Length of a list

The length of an empty list is 0.

The length of any other list is 1 + the length of the tail of that list.



One point worth stressing: the order of these clauses can make a difference when you translate them into code. Elixir tries functions from the top down, executing the first match. So the following code will not work:

mm/factorial1-bad.exs

defmodule BadFactorial do



def of(n), do: n * of(n-1)



def of(0), do: 1



end





The first function definition will always match and the second will never be called. But Elixir has you covered—when you try to compile this, you’ll get a warning:

iex> c "factorial1-bad.exs"



.../factorial1-bad.ex:3: this clause cannot match because a previous clause at



line 2 always matches





One more thing: when you have multiple implementations of the same function, they should be adjacent in the source file.





Your Turn


Exercise: ModulesAndFunctions-4

Implement and run a function sum(n) that uses recursion to calculate the sum of the integers from 1 to n. You’ll need to write this function inside a module in a separate file. Then load up iex, compile that file, and try your function.



Exercise: ModulesAndFunctions-5

Write a function gcd(x,y) that finds the greatest common divisor between two nonnegative integers. Algebraically, gcd(x,y) is x if y is zero; it’s gcd(y, rem(x,y)) otherwise.





Guard Clauses


We’ve seen that pattern matching allows Elixir to decide which function to invoke based on the arguments passed. But what if we need to distinguish based on their types or on some test involving their values? For this, you use guard clauses. These are predicates that are attached to a function definition using one or more when keywords. When doing pattern matching, Elixir first does the conventional parameter-based match and then evaluates any when predicates, executing the function only if at least one predicate is true.

mm/guard.exs

defmodule Guard do



def what_is(x) when is_number(x) do



IO.puts "#{x} is a number"



end



def what_is(x) when is_list(x) do



IO.puts "#{inspect(x)} is a list"



end



def what_is(x) when is_atom(x) do



IO.puts "#{x} is an atom"



end



end





Guard.what_is(99) # => 99 is a number



Guard.what_is(:cat) # => cat is an atom



Guard.what_is([1,2,3]) # => [1,2,3] is a list





Recall our previous factorial example.

mm/factorial1.exs

defmodule Factorial do



def of(0), do: 1



def of(n), do: n * of(n-1)



end





If we were to pass it a negative number, it would loop forever—no matter how many times you decrement n, it will never be zero. So it is a good idea to add a guard clause to stop this from happening.

mm/factorial2.exs

defmodule Factorial do



def of(0), do: 1



def of(n) when n > 0 do



n * of(n-1)



end



end





If you run this code with a negative argument, none of the functions will match:

iex> c "factorial2.exs"



[Factorial]



iex> Factorial.of -100



** (FunctionClauseError) no function clause matching in Factorial.of/1...





Guard-Clause Limitations


You can write only a subset of Elixir expressions in guard clauses. The following list comes from the Getting Started guide.[7]





Comparison operators

==, !=, ===, !==, >, <, <=, >=





Boolean and negation operators

or, and, not, !. Note that || and && are not allowed.





Arithmetic operators

+, -, *, /





Join operators

<> and ++, as long as the left side is a literal.





The in operator

Membership in a collection or range





Type-check functions

These built-in Erlang functions return true if their argument is a given type. You can find their documentation online.[8]



is_atom is_binary is_bitstring is_boolean is_exception is_float is_function is_integer is_list is_map is_number is_pid is_port is_record is_reference is_tuple





Other functions

These built-in functions return values (not true or false). Their documentation is online, on the same page as the type-check functions.



abs(number) bit_size(bitstring) byte_size(bitstring) div(number,number) elem(tuple, n) float(term) hd(list) length(list) node() node(pid|ref|port) rem(number,number) round(number) self() tl(list) trunc(number) tuple_size(tuple)





Default Parameters


When you define a named function, you can give a default value to any of its parameters by using the syntax param \\ value. When you call a function that is defined with default parameters, Elixir compares the number of arguments you are passing with the number of required parameters for the function. If you’re passing fewer arguments than the number of required parameters, then there’s no match. If the two numbers are equal, then the required parameters take the values of the passed arguments, and the other parameters take their default values. If the count of passed arguments is greater than the number of required parameters, Elixir uses the excess to override the default values of some or all parameters. Parameters are matched left to right.

mm/default_params.exs

defmodule Example do



def func(p1, p2 \\ 2, p3 \\ 3, p4) do



IO.inspect [p1, p2, p3, p4]



end



end





Example.func("a", "b") # => ["a",2,3,"b"]



Example.func("a", "b", "c") # => ["a","b",3,"c"]



Example.func("a", "b", "c", "d") # => ["a","b","c","d"]





Default arguments can behave surprisingly when Elixir does pattern matching. For example, compile the following:

def func(p1, p2 \\ 2, p3 \\ 3, p4) do



IO.inspect [p1, p2, p3, p4]



end





def func(p1, p2) do



IO.inspect [p1, p2]



end





and you’ll get this error:

** (CompileError) default_params.exs:7: def func/2 conflicts with



defaults from def func/4





That’s because the first function definition (with the default parameters) matches any call with two, three, or four arguments.

There’s one more thing with default parameters. Here’s a function with multiple heads that also has a default parameter:

mm/default_params1.exs

defmodule DefaultParams1 do





def func(p1, p2 \\ 123) do



IO.inspect [p1, p2]



end





def func(p1, 99) do



IO.puts "you said 99"



end





end





IO





If you compile this, you’ll get an error:

** (CompileError) default_params1.exs.exs:8: def func/2 has default



values and multiple clauses, define a function head



with the defaults





The intent is to reduce the confusion that can arise with defaults. Simply add a function head with no body that contains the default parameters, and use regular parameters for the rest. The defaults will apply to all calls to the function.

mm/default_params2.exs

defmodule Params do





def func(p1, p2 \\ 123)





def func(p1, p2) when is_list(p1) do



"You said #{p2} with a list"



end





def func(p1, p2) do



"You passed in #{p1} and #{p2}"



end





end





IO.puts Params.func(99) # You passed in 99 and 123



IO.puts Params.func(99, "cat") # You passed in 99 and cat



IO.puts Params.func([99]) # You said 123 with a list



IO.puts Params.func([99], "dog") # You said dog with a list





Your Turn


Exercise: ModulesAndFunctions-6

I’m thinking of a number between 1 and 1000.…

The most efficient way to find the number is to guess halfway between the low and high numbers of the range. If our guess is too big, then the answer lies between the bottom of the range and one less than our guess. If our guess is too small, then the answer lies between one more than our guess and the end of the range.

Your API will be guess(actual, range), where range is an Elixir range.

Your output should look similar to this: iex> Chop.guess(273, 1..1000)



Is it 500



Is it 250



Is it 375



Is it 312



Is it 281



Is it 265



Is it 273



273





Hints:You may need to implement helper functions with an additional parameter (the currently guessed number).

The div(a,b) function performs integer division.

Guard clauses are your friends.

Patterns can match the low and high parts of a range (a..b=4..8).





Private Functions


The defp macro defines a private function—one that can be called only within the module that declares it.

You can define private functions with multiple heads, just as you can with def. However, you cannot have some heads private and others public. That is, the following code is not valid:

def fun(a) when is_list(a), do: true



defp fun(a), do: false





|> — The Amazing Pipe Operator


I’ve saved the best for last, at least when it comes to functions.

You’ve all seen code like this:

people = DB.find_customers



orders = Orders.for_customers(people)



tax = sales_tax(orders, 2013)



filing = prepare_filing(tax)





Bread-and-butter programming. We did it because the alternative was to write

filing = prepare_filing(sales_tax(Orders.for_customers(DB.find_customers), 2013))





and that’s the kind of code that you use to get kids to eat their vegetables. Not only is it hard to read, but you have to read it inside out if you want to see the order in which things get done.

Elixir has a better way of writing it.

filing = DB.find_customers



|> Orders.for_customers



|> sales_tax(2013)



|> prepare_filing





The |> operator takes the result of the expression to its left and inserts it as the first parameter of the function invocation to its right. So the list of customers the first call returns becomes the argument passed to the for_customers function. The resulting list of orders becomes the first argument to sales_tax, and the given parameter, 2013, becomes the second.

val |> f(a,b) is basically the same as calling f(val,a,b), and

list



|> sales_tax(2013)



|> prepare_filing





is the same as prepare_filing(sales_tax(list, 2013)).

In the previous example, I wrote each term in the expression on a separate line, and that’s perfectly valid Elixir. But you can also chain terms on the same line.

iex> (1..10) |> Enum.map(&(&1*&1)) |> Enum.filter(&(&1 < 40))



[1, 4, 9, 16, 25, 36]





Note that I had to use parentheses in that code—the & shortcut and the pipe operator fight otherwise.

Let me repeat that—you should always use parentheses around function parameters in pipelines.

The key aspect of the pipe operator is that it lets you write code that pretty much follows your spec’s form. For the sales-tax example, you might have jotted this on some paper:

Get the customer list.

Generate a list of their orders.

Calculate tax on the orders.

Prepare the filing.



To take this from a napkin spec to running code, you just put |> between the items and implement each as a function.

DB.find_customers



|> Orders.for_customers



|> sales_tax(2013)



|> prepare_filing





Programming is transforming data, and the |> operator makes that transformation explicit.

And now this book’s subtitle makes sense.





Modules


Modules provide namespaces for things you define. We’ve already seen them encapsulating named functions. They also act as wrappers for macros, structs, protocols, and other modules.

If we want to reference a function defined in a module from outside that module, we need to prefix the reference with the module’s name. We don’t need that prefix if code references something inside the same module as itself, as in the following example.

defmodule Mod do



def func1 do



IO.puts "in func1"



end



def func2 do



func1



IO.puts "in func2"



end



end





Mod.func1



Mod.func2





func2 can call func1 directly because it is inside the same module. Outside the module, you have to use the fully qualified name, Mod.func1.

Just as you do in your favorite language, Elixir programmers use nested modules to impose structure for readability and reuse. After all, every programmer is a library writer.

To access a function in a nested module from the outside scope, prefix it with all the module names. To access it within the containing module, use either the fully qualified name or just the inner module name as a prefix.

defmodule Outer do



defmodule Inner do



def inner_func do



end



end





def outer_func do



Inner.inner_func



end



end





Outer.outer_func



Outer.Inner.inner_func





Module nesting in Elixir is an illusion—all modules are defined at the top level. When we define a module inside another, Elixir simply prepends the outer module name to the inner module name, putting a dot between the two. This means we can directly define a nested module.

defmodule Mix.Tasks.Doctest do



def run do



end



end





Mix.Tasks.Doctest.run





It also means there’s no particular relationship between the modules Mix and Mix.Tasks.Doctest.





Directives for Modules


Elixir has three directives that simplify working with modules. All three are executed as your program runs, and the effect of all three is lexically scoped—it starts at the point the directive is encountered, and stops at the end of the enclosing scope. This means a directive in a module definition takes effect from the place you wrote it until the end of the module; a directive in a function definition runs to the end of the function.





The import Directive


The import directive brings a module’s functions and/or macros into the current scope. If you use a particular module a lot in your code, import can cut down the clutter in your source files by eliminating the need to repeat the module name time and again.

For example, if you import the flatten function from the List module, you’d be able to call it in your code without having to specify the module name.

mm/import.exs

defmodule Example do



def func1 do



List.flatten [1,[2,3],4]



end



def func2 do



import List, only: [flatten: 1]



flatten [5,[6,7],8]



end



end





The full syntax of import is

import Module [, only:|except: ]





The optional second parameter lets you control which functions or macros are imported. You write only: or except:, followed by a list of name: arity pairs. It is a good idea to use import in the smallest possible enclosing scope and to use only: to import just the functions you need.

import List, only: [ flatten: 1, duplicate: 2 ]





Alternatively, you can give only: one of the atoms :functions or :macros, and import will bring in only functions or macros.





The alias Directive


The alias directive creates an alias for a module. One obvious use is to cut down on typing.

defmodule Example do



def func do



alias Mix.Tasks.Doctest, as: Doctest



doc = Doctest.setup



doc.run(Doctest.defaults)



end



end





We could have abbreviated this alias directive to alias Mix.Tasks.Doctest because the as: parameter defaults to the last part of the module name.





The require Directive


You require a module if you want to use the macros defined in that module. The require directive ensures that the given module is loaded before your code tries to use any of the macros it defines. We’ll talk about require when we talk about macros.





Module Attributes


Elixir modules each have associated metadata. Each item of metadata is called an attribute of the module and is identified by a name. Inside a module, you can access these attributes by prefixing the name with an at sign (@).

You can give an attribute a value using the syntax

@name value





This works only at the top level of a module—you cannot set an attribute value inside a function definition. You can, however, access attributes inside functions.

mm/attributes.exs

defmodule Example do



@author "Dave Thomas"



def get_author do



@author



end



end





IO.puts "Example was written by #{Example.get_author}"





You can set the same attribute multiple times in a module. If you access that attribute in a named function in that module, the value you see will be the value in effect when the function is defined.

mm/attributes1.exs

defmodule Example do



@attr "one"



def first, do: @attr



@attr "two"



def second, do: @attr



end





IO.puts "#{Example.first} #{Example.second}" # => one two





These attributes are not variables in the conventional sense. Use them for configuration and metadata only. (Many Elixir programmers employ them where Java or Ruby programmers might use constants.)





Module Names: Elixir, Erlang, and Atoms


When we write modules in Elixir, they have names such as String or PhotoAlbum. We call functions in them using calls such as String.length("abc").

What’s happening here is subtle. Internally, module names are just atoms. When you write a name starting with an uppercase letter, such as IO, Elixir converts it internally into an atom called Elixir.IO.

iex> is_atom IO



true



iex> to_string IO



"Elixir.IO"



iex> :"Elixir.IO" === IO



true





So a call to a function in a module is really an atom followed by a dot followed by the function name. And, indeed, we can call functions like this:

iex> IO.puts 123



123



:ok



iex> :"Elixir.IO".puts 123



123



:ok





Calling a Function in an Erlang Library


The Erlang conventions for names are different—variables start with an uppercase letter and atoms are simple lowercase names. So, for example, the Erlang module timer is called just that, the atom timer. In Elixir we write that as :timer. If you want to refer to the tc function in timer, you’d write :timer.tc. (Note the colon at the start.)

Say we want to output a floating-point number in a three-character-wide field with one decimal place. Erlang has a function for this. A search for erlang format takes us to the description of the format function in the Erlang io module.[9]

Reading the description, we see that Erlang expects us to call io.format. So, in Elixir we simply change the Erlang module name to an Elixir atom:

iex> :io.format("The number is ~3.1f~n", [5.678])



The number is 5.7



:ok





Finding Libraries


If you’re looking for a library to use in your app, you’ll want to look first for existing Elixir modules. The built-in ones are documented on the Elixir website,[10] and others are listed at http://hex.pm and on GitHub (search for elixir).

If that fails, search for a built-in Erlang library or search the Web.[11] If you find something written in Erlang, you’ll be able to use it in your project (we’ll cover how in the chapter on projects,). But be aware that the Erlang documentation for a library follows Erlang conventions. Variables start with uppercase letters, and identifiers starting with a lowercase letter are atoms (so Erlang would say tomato and Elixir would say :tomato). A summary of the differences between Elixir and Erlang is available online.[12]

Now that we’ve looked at functions, let’s move on to the data they manipulate. And where better to start than with lists, the subject of the next chapter?





Your Turn


Exercise: ModulesAndFunctions-7

Find the library functions to do the following, and then use each in iex. (If the word Elixir or Erlang appears at the end of the challenge, then you’ll find the answer in that set of libraries.)Convert a float to a string with two decimal digits. (Erlang)

Get the value of an operating-system environment variable. (Elixir)

Return the extension component of a file name (so return .exs if given "dave/test.exs"). (Elixir)

Return the process’s current working directory. (Elixir)

Convert a string containing JSON into Elixir data structures. (Just find; don’t install.)

Execute a command in your operating system’s shell.





Footnotes


[7]

http://elixir-lang.org/getting_started/5.html



[8]

http://erlang.org/doc/man/erlang.html#is_atom-1



[9]

http://erlang.org/doc/man/io.html#format-2>



[10]

http://elixir-lang.org/docs/



[11]

http://erlang.org/doc/ and http://erldocs.com/R15B/ (Note that the latter is slightly out of date.)



[12]

http://elixir-lang.org/crash-course.html