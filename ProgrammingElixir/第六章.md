

## 第六章 命名函数和模块

本章知识：


*  模块，代码的基本单元 
*  定义公有和私有命名函数
*  卫（Guard）句子句
*  模块的指令和熟悉
*  调用Erlang模块的函数


程序由几行代码开始，逐渐变多之后，开发者期望一种结构化的方式组织代码。Elixir模块化代码很简单。你只需要将函数拆分写入模块中，当然Elixir中的函数（指命名函数，接下来除非特别指出匿名函数，否则所有函数都指命名函数）在模块中定义。

先看一个简单的例子。在你的目录中创建一个Elixir源文件`times.exs`


mm/times.exs

```elixir
defmodule Times do
	def double(n) do
		n * 2
	end
end
```

我们定义了一个`Times`模块。该模块包含一个单独的`double`函数。该函数只有一个参数，在Elixir中，是通过参数的个数来区分不同模块的函数子句。例如上面的函数定义式是`double/1`



### 编译模块

有两种方式编译文件。第一种使用使用iex载入文件并编译：

```elixir
$ iex times.exs
iex> Times.double 4
8
```

命令行中输入iex + 文件名就可以编译源文件并将编译结果的上下文载入iex提示界面。


如果你先进入了iex交互提示界面，可以使用c帮助函数进行编译。

```elixir
iex> c "times.exs"
[Times]
iex> Times.double(4)
8
iex> Times.double(123)
246
```

这一行`c "times.exs"`代码将对源文件进行编译并载入编译后的程序。使用模块加函数名即可调用函数，即`Times.double`。

如果给函数传入一个整数将会发生什么呢？

```elixir
iex> Times.double("cat")
** (ArithmeticError) bad argument in arithmetic expression
times.exs:3: Times.double/1
```

堆栈信息中可以看见发生了一个`ArithmeticError`异常，第一行告诉我们发生了什么错误。下一行告诉我们错误发生在什么地方。注意错误信息中是定义式`Times.double/1`描述出错的函数。

Elixir中通过函数名及其参数个数（arity）来识别不同的函数子句。`double`函数有一个参数，因此被标记为`double/1`。如果它有三个函数，则会被标注为`double/3`。无需为Elixir担心无法区分这两个函数。设想一下，如果有两个同名函数挨着，即使同名有不同的参数个数，对于人还是无法容易的分辨。为了避免这种情况，请尽量不用把不相关的函数使用相同的名字。


### 函数体也是一个块


`do...end`块是组织表达式和代码的一种方式。Elxir的模块和函数使用他们定义，控制代码结构，以及任何需要处理的代码体。

可是，`do…end`并不是基础语法。他们的本质是像这样的：

	def double(n), do: n * 2

可以给`do:`提供任何使用小括号包裹的表达式。


```elixir
def greet(greeting, name), do: (
	IO.puts greeting
	IO.puts "How're you doing, #{name}?"
)
```

`do…end`只是组织代码块的一个语法糖，他们都可以转换成`do: from`的形式（`do: from`本身并没有特别之处，只是一个简单的关键字列表）。人们习惯使用`do: form`语法来表示单行的代码块的时候，使用`do…end`组织多行代码块。

例如我们的例子其实可以改写一下：

mm/times1.exs

```elixir
defmodule Times do
	def double(n), do: n * 2
end
```

甚至可以这么写：

```elixir
defmodule Times, do: (def double(n), do: n*2)
```

（最好不好这样做，可读性不好）


### 函数调用及其模式匹配


前一章，我们了解了匿名函数式的参数是如果通过模式匹配将参数应用于函数体。这个规则对于命名函数也同样适用。不同的地方在于，命名函数需要写多个不同参数列表和函数体子句的函数。尽管看起来像是定义了多个函数，其实这是一个哈市的多个子句而已。

当你调用一个命名函数的时候，Elixir会首先把你传入的参数和第一个函数子句进行模式匹配。只有前面的函数子句没有匹配，才会尝试和后面的函数子句进行匹配（记住，参数的个数必须和模式匹配相同）。直到匹配完所有的函数子句。


我们来玩一玩。编写一个从1到n的阶乘（`n!`）函数`factorial`。通常0!等于1。
类似数学语言的表达：

```elixir
factorial(0) → 1
factorial(n) → n * factorial(n-1)
```

这是一个阶乘的伪代码，但是它已经和Elixir实现很接近了。

mm/factorial1.exs

```elixir
defmodule Factorial do

	def of(0), do: 1
	def of(n), do: n * of(n-1)
end
```


这里我们定了两个同名的函数`of`。调用`Factorial.of(2)`，Elixir会用参数2与第一个of函数的参数模式进行匹配，0不匹配2，第一个函数匹配失败。然后，Elixir会把这个参数和第二个函数进行模式匹配`n=2`，匹配成功，然后把`n`传入该子句的函数体进行求值运算。其中由递归的调用`of(2-1)`。此时同样的的处理过程，还是第二个函数匹配调用，再接下来递归调用，`Factorial.of(0)`，此时则匹配第一个函数了。该函数执行返回1，直到递归回溯完毕。Elixir会自动回溯栈，将所有数字相乘法，然后返回答案。这个`factorial `模块实现了正常的功能，但是这段代码还可以使用尾递归优化提高。

先运行看看结果：

```elixir
iex> c "factorial1.exs"
[Factorial]
iex> Factorial.of(3)
6
iex> Factorial.of(7)
5040
iex> Factorial.of(10)
3628800
iex> Factorial.of(1000)
40238726007709377354370243392300398571937486421071463254379991042993851239862
90205920442084869694048004799886101971960586316668729948085589013238296699445
...
00624271243416909004153690105933983835777939410970027753472000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000
```

Elixir中使用模式匹配设计和编程很普遍（几乎所有函数式语言都如此）。先来说一下最简单的情况下，一个过程有了明确的答案。将是解决问题的切入点。然后找一个递归解决方案，将这些过程集合处理。

更多的例子：

* n个数的和

* 第一个0的和是0

* 第n个数的和又n-1个数的和与n相加。

列表的长度

* 空列表的长度是0

& 任何列表的长度都等于第一个元素的长度1加上剩余列表元素的长度


重要的知识点：将上面的语句用代码表达，将会写出多个子句函数。Elixir总是从最先定义的函数进行模式匹配。一旦前面的满足了要求，就不会往下匹配了。所有下面的代码将不会工作：


mm/factorial1-bad.exs

```elixir
defmodule BadFactorial do
	def of(n), do: n * of(n-1)
	def of(0), do: 1
end
```

无论是什么参数，第一个函数子句都能匹配，第二个函数永远不会被执行。当然，出现这种情况，Elixir会在定义完毕之后给出一个警告：

```elixir
iex> c "factorial1-bad.exs"
.../factorial1-bad.ex:3: this clause cannot match because a previous clause at
```


第二行的函数将永远匹配。


再提醒一下: 当你有多个同名函数的子句的时候，它们应该写在源文件相近的地方。


### 卫子句

通过传入参数的模式匹配，Elixir可以选择匹配的函数调用。但是，当我们需要匹配的结果是基于不同类型或者是匹配特定的值的时候该怎么办呢？不用担心，Elixir提供了卫子句。这是通过关键字给函数定义添加谓词。当模式匹配的时候，Elxir首先会使用参数的模式匹配，然后在针对when关键字的子句进行逻辑判断，如果条件为真，才执行对于的函数子句。


mm/guard.exs

```elixir
defmodule Guard do

	def what_is(x) when is_number(x) do
		IO.puts "#{x} is a number"
	end
	
	def what_is(x) when is_list(x) do
		IO.puts "#{inspect(x)} is a list"
	end

	def what_is(x) when is_atom(x) do
		IO.puts "#{x} is an atom"
	end
end

Guard.what_is(99) # => 99 is a number

Guard.what_is(:cat) # => cat is an atom

Guard.what_is([1,2,3]) # => [1,2,3] is a list
```



从新看看阶乘`factorial`模块

mm/factorial1.exs

```elixir
defmodule Factorial do

	def of(0), do: 1

	def of(n), do: n * of(n-1)

end
```

如果我们传入一个负数，那么这段代码将会进入死循环，一直递归调用，用于不会满足递归结果的条件，即n等于0。因此我们可以通过卫子句对参数进行过滤，才能愉快的玩耍。


mm/factorial2.exs

```elixir
defmodule Factorial do

	def of(0), do: 1

	def of(n) when n > 0 do
		n * of(n-1)
	end
end
```

此时调用的时候再传入负数，第二个匹配的函数将会执行卫子句检查，返回false将不会执行函数子句，即没有函数匹配。（没有函数匹配将会抛出异常）

iex> c "factorial2.exs"
[Factorial]
iex> Factorial.of -100
** (FunctionClauseError) no function clause matching in Factorial.of/1...
```


#### 卫子句的限制 


你只能写一些特定的Elixir表达式。下面的例子来自官方的Getting Started guide

* 比较操作符

	==, !=, ===, !==, >, <, <=, >=

* 布尔操作符和取反操作符

	or, and, not, !.  注意：|| 和 && 是不能用的.

* 算术操作符

+, -, *, /

* 连接操作符

	<> and ++

* in操作符
	成员的集合和范围



### 类型检测函数


下面是一些内建类型检测函数，具体可以参考其官方文档。


* is_atom
* is_binary 
* is_bitstring 
* is_boolean 
* is_exception 
* is_float 
* is_function 
* is_integer 
* is_l
* ist 
* is_map 
* is_number 
* is_pid 
* is_port 
* is_record 
* is_reference 
* is_tuple


### 其他函数

下面的内建函数将返回参数的值，而不是`true` 或者 `false`

* abs(number) 
* bit_size(bitstring) 
* byte_size(bitstring) 
* div(number,number) 
* elem(tuple, n) 
* float(term) 
* hd(list) 
* length(list) 
* node() 
* node(pid|ref|port) 
* rem(number,number) 
* round(number) 
* self() 
* tl(list) 
* trunc(number) 
* tuple_size(tuple) 


### 默认参数


定义命名函数的时候，可以使用`\\`语法符给函数的参数设置默认值。调用函数的时候，如果该参数没有传值，则函数使用默认的参数。Elixir还会检测调用函数的时候所传入的参数个数，如果传入的参数少于必须参数，则不会匹配成功。如果正好满足必须的参数，那么必须参数则使用传入的参数进行匹配，其他的就使用其默认值。如果传入的参数个数大于必须参数的个数，那么就会匹配必须参数之后，覆盖默认参数的值。参数匹配是由左向右的。

mm/default_params.exs

```elixir
defmodule Example do

	def func(p1, p2 \\ 2, p3 \\ 3, p4) do
		IO.inspect [p1, p2, p3, p4]
	end
end

Example.func("a", "b") # => ["a",2,3,"b"]
Example.func("a", "b", "c") # => ["a","b",3,"c"]
Example.func("a", "b", "c", "d") # => ["a","b","c","d"]
```

Elixir模式匹配的时候，默认参数有惊人的表现。录入，编译下面代码：

```elixir
def func(p1, p2 \\ 2, p3 \\ 3, p4) do
	IO.inspect [p1, p2, p3, p4]
end

def func(p1, p2) do
	IO.inspect [p1, p2]
end
```

你会得到错误：


```elixir
** (CompileError) default_params.exs:7: def func/2 conflicts with
defaults from def func/4
```

因为第一个函数子句的定义（带有默认参数），无论参数是两个，三个还是四个，几乎可以匹配任何第二个函数子句的模式。也就是第二个函数永远不会被匹配。

对于默认函数，还有一点需要知道。下面一个函数两个函数头（双函数子句）的情况，只不过另外一个写清楚了默认值：

mm/default_params1.exs

```elixir
defmodule DefaultParams1 do

	def func(p1, p2 \\ 123) do
		IO.inspect [p1, p2]
	end


	def func(p1, 99) do
		IO.puts "you said 99"
	end
end
```
 
编译会报错(两个子句都有默认的参数了)：

```
** (CompileError) default_params1.exs.exs:8: def func/2 has default
values and multiple clauses, define a function head
```

### 使用默认参数 


为了降低默认值带来的函数冲突。会把带有默认参数定义写在函数的头部，只需要声明却不写函数体。剩下的函数子句就使用正常的参数。下面的例子中，默认参数的声明写在了头部，这个规则使用下面两个函数的子句。

mm/default_params2.exs

```elixir
defmodule Params do

	def func(p1, p2 \\ 123)

	def func(p1, p2) when is_list(p1) do

		"You said #{p2} with a list"
	end

	def func(p1, p2) do

		"You passed in #{p1} and #{p2}"
	end
end

IO.puts Params.func(99) 			# You passed in 99 and 123 
IO.puts Params.func(99, "cat") 		# You passed in 99 and cat
IO.puts Params.func([99]) 			# You said 123 with a list
IO.puts Params.func([99], "dog") 	# You said dog with a list
```

上面的定义，其实等价于（只不过把默认参数提取出来了）：

```elixir
defmodule Params do
	def func(p1, p2 \\ 123) when is_list(p1) do

		"You said #{p2} with a list"
	end

	def func(p1, p2 \\ 123) do

		"You passed in #{p1} and #{p2}"
	end
end
```

#### 私有函数

`defp`宏可以定义声明一个私有函数，私有函数只能在声明它的模块内部调用。

也可以定义多个私有函数，就像使用`def`定义函数一样。可是，不能定义参数一致的同名公有和私有函数。正如下面是非法的：

```
def fun(a) when is_list(a), do: true

defp fun(a), do: false
```

### |> — 神奇的管道操作符


I’ve saved the best for last, at least when it comes to functions.

You’ve all seen code like this:

精彩被保留到了最后。在你了解函数之后，你会见过这样的代码：


```
people = DB.find_customers
orders = Orders.for_customers(people)
tax = sales_tax(orders, 2013)
filing = prepare_filing(tax)
```
面包黄油（Bread-and-butter）编程。我们还可以选择这样简写：

	filing = prepare_filing(sales_tax(Orders.for_customers(DB.find_customers), 2013))

上面的代码一个函数的调用使用上一个函数的结果作为参数，就像小孩子吃蔬菜一样。不仅比较难读，而且如果你想知整个过程的顺序，不得不阅读里面的内容。

Elixir有一个更好的方式：

```elixir
filing = DB.find_customers
			|> Orders.for_customers
			|> sales_tax(2013)
			|> prepare_filing

```
`|>`操作符会把左边表达式的结果当成参数传入右边的函数。第一个函数调用返回customers的列表，这个结果传给for_customers函数。for_customers调用的返回结果order，order作为第一个参数传给sales_tax。此时2013变成了第二个参数。




`val |> f(a,b)` 等价于 `f(val,a,b)`

```
list
|> sales_tax(2013)
|> prepare_filing
```

等价于 `prepare_filing(sales_tax(list, 2013))`.

上面的例子，每一项我都单独的写了一行，这在Elixir已经不过时了。有逼格的方式是写成一行链式的效果：

```
iex> (1..10) |> Enum.map(&(&1*&1)) |> Enum.filter(&(&1 < 40))
[1, 4, 9, 16, 25, 36]
```

注意我使用`&`语法糖来作为函数的缩写，同时也使用了管道操作符。 

我再重复一次，你总是需要在管道符号内使用圆括号调用函数。管道符的好处是让你写的代码符合规范和有条理，简短而漂亮。例如sales-tax 的例子，你可以在纸上写下：


* 获取顾客列表        
* 通过顾客列表生成一个订单列表
* 计算出租车的订单价值
* 准备出租车


从餐巾纸到代码规范，你只需要用|>来串联每一个函数的调用。


```elixir
DB.find_customers               	# 获取顾客列表  
	|> Orders.for_customers 		# 通过顾客列表生成一个订单列表
	|> sales_tax(2013)				# 计算出租车的订单价值
	|> prepare_filing				# 准备出租车
```

编程是数据的转换，|>很好的体现了数据转换。还记得本书的副标题么？


### 模块（Modules）


Modules provide namespaces for things you define. We’ve already seen them encapsulating named functions. They also act as wrappers for macros, structs, protocols, and other modules.

If we want to reference a function defined in a module from outside that module, we need to prefix the reference with the module’s name. We don’t need that prefix if code references something inside the same module as itself, as in the following example.

```elixir
defmodule Mod do

	def func1 do
		IO.puts "in func1"
	end

	def func2 do
		func1
		IO.puts "in func2"
	end
end

Mod.func1
Mod.func2
```

func2 can call func1 directly because it is inside the same module. Outside the module, you have to use the fully qualified name, Mod.func1.

Just as you do in your favorite language, Elixir programmers use nested modules to impose structure for readability and reuse. After all, every programmer is a library writer.

To access a function in a nested module from the outside scope, prefix it with all the module names. To access it within the containing module, use either the fully qualified name or just the inner module name as a prefix.

```
defmodule Outer do
	defmodule Inner do
		def inner_func do
		end
	end

	def outer_func do
		Inner.inner_func
	end
end

Outer.outer_func

Outer.Inner.inner_func
```

Module nesting in Elixir is an illusion—all modules are defined at the top level. When we define a module inside another, Elixir simply prepends the outer module name to the inner module name, putting a dot between the two. This means we can directly define a nested module.

```elixir
defmodule Mix.Tasks.Doctest do
	def run do
	end
end

Mix.Tasks.Doctest.run
```

It also means there’s no particular relationship between the modules Mix and Mix.Tasks.Doctest.

#### 模块指令 （Directives for Modules）


Elixir has three directives that simplify working with modules. All three are executed as your program runs, and the effect of all three is lexically scoped—it starts at the point the directive is encountered, and stops at the end of the enclosing scope. This means a directive in a module definition takes effect from the place you wrote it until the end of the module; a directive in a function definition runs to the end of the function.





The import Directive


The import directive brings a module’s functions and/or macros into the current scope. If you use a particular module a lot in your code, import can cut down the clutter in your source files by eliminating the need to repeat the module name time and again.

For example, if you import the flatten function from the List module, you’d be able to call it in your code without having to specify the module name.

mm/import.exs

```elixir
defmodule Example do

	def func1 do
		List.flatten [1,[2,3],4]
	end

	def func2 do
		import List, only: [flatten: 1]

		flatten [5,[6,7],8]
	end
end
```




The full syntax of import is

import Module [, only:|except: ]





The optional second parameter lets you control which functions or macros are imported. You write only: or except:, followed by a list of name: arity pairs. It is a good idea to use import in the smallest possible enclosing scope and to use only: to import just the functions you need.

import List, only: [ flatten: 1, duplicate: 2 ]





Alternatively, you can give only: one of the atoms :functions or :macros, and import will bring in only functions or macros.





The alias Directive


The alias directive creates an alias for a module. One obvious use is to cut down on typing.

```elxir
defmodule Example do

	def func do

		alias Mix.Tasks.Doctest, as: Doctest

		doc = Doctest.setup
		doc.run(Doctest.defaults)
	end
end
```

We could have abbreviated this alias directive to alias Mix.Tasks.Doctest because the as: parameter defaults to the last part of the module name.

#### require 指令


You require a module if you want to use the macros defined in that module. The require directive ensures that the given module is loaded before your code tries to use any of the macros it defines. We’ll talk about require when we talk about macros.





#### 模块属性 （Module Attributes）


Elixir modules each have associated metadata. Each item of metadata is called an attribute of the module and is identified by a name. Inside a module, you can access these attributes by prefixing the name with an at sign (@).

You can give an attribute a value using the syntax

@name value


This works only at the top level of a module—you cannot set an attribute value inside a function definition. You can, however, access attributes inside functions.

mm/attributes.exs
```elixir
defmodule Example do

	@author "Dave Thomas"
	def get_author do
		@author
	end
end

IO.puts "Example was written by #{Example.get_author}"
```



You can set the same attribute multiple times in a module. If you access that attribute in a named function in that module, the value you see will be the value in effect when the function is defined.

mm/attributes1.exs
```elixir
defmodule Example do

	@attr "one"

	def first, do: @attr

	@attr "two"

	def second, do: @attr

end

IO.puts "#{Example.first} #{Example.second}" # => one two
```

These attributes are not variables in the conventional sense. Use them for configuration and metadata only. (Many Elixir programmers employ them where Java or Ruby programmers might use constants.)

Module Names: Elixir, Erlang, and Atoms


When we write modules in Elixir, they have names such as String or PhotoAlbum. We call functions in them using calls such as String.length("abc").

What’s happening here is subtle. Internally, module names are just atoms. When you write a name starting with an uppercase letter, such as IO, Elixir converts it internally into an atom called Elixir.IO.

```elixir
iex> is_atom IO
true
iex> to_string IO
"Elixir.IO"
iex> :"Elixir.IO" === IO
true
```

So a call to a function in a module is really an atom followed by a dot followed by the function name. And, indeed, we can call functions like this:
```elixir
iex> IO.puts 123
123
:ok
iex> :"Elixir.IO".puts 123
123
:ok
```

Calling a Function in an Erlang Library


The Erlang conventions for names are different—variables start with an uppercase letter and atoms are simple lowercase names. So, for example, the Erlang module timer is called just that, the atom timer. In Elixir we write that as :timer. If you want to refer to the tc function in timer, you’d write :timer.tc. (Note the colon at the start.)

Say we want to output a floating-point number in a three-character-wide field with one decimal place. Erlang has a function for this. A search for erlang format takes us to the description of the format function in the Erlang io module.[9]

Reading the description, we see that Erlang expects us to call io.format. So, in Elixir we simply change the Erlang module name to an Elixir atom:

```elixir
iex> :io.format("The number is ~3.1f~n", [5.678])
The number is 5.7
:ok
```




Finding Libraries


If you’re looking for a library to use in your app, you’ll want to look first for existing Elixir modules. The built-in ones are documented on the Elixir website,[10] and others are listed at http://hex.pm and on GitHub (search for elixir).

If that fails, search for a built-in Erlang library or search the Web.[11] If you find something written in Erlang, you’ll be able to use it in your project (we’ll cover how in the chapter on projects,). But be aware that the Erlang documentation for a library follows Erlang conventions. Variables start with uppercase letters, and identifiers starting with a lowercase letter are atoms (so Erlang would say tomato and Elixir would say :tomato). A summary of the differences between Elixir and Erlang is available online.[12]

Now that we’ve looked at functions, let’s move on to the data they manipulate. And where better to start than with lists, the subject of the next chapter?









