


Chapter 8





Dictionaries: Maps, HashDicts,

Keywords, Sets, and Structs




* * *



In this chapter, we’ll see

The two and a half dictionary data types

The General Dictionary API

Pattern matching and updating maps

Structs

Nested data structures



A dictionary is a data type that associates keys with values.

We’ve already looked briefly at a couple of dictionary types: maps and keyword lists. In this short chapter we’ll cover how to use them with pattern matching and how to update them. We’ll also look at HashDict, another implementation of dictionaries. Finally we’ll look at the Keyword module, which implements a specialized dictionary intended for storing function and program options, and the Set module, which implements sets.

First, though, let’s answer a common question—how do we choose an appropriate dictionary type for a particular need?





How to Choose Between Maps, HashDicts, and Keywords


Ask yourself these questions (in this order):

Will I want more than one entry with the same key?

If so, you’ll have to use the Keyword module.

Do I need to guarantee the elements are ordered?

If so, again, use the Keyword module.

Do I want to pattern-match against the contents (for example, matching a dictionary that has a key of :name somewhere in it)?

If so, use a map.



Will I be storing more than a few hundred entries in it?

If so, use a HashDict. With R17 of the BEAM virtual machine (which runs Erlang), maps are slow, particularly when adding new items.[13] This should improve in R18.





Dictionaries


Maps and hashdicts both implement the Dict behaviour. The Keyword module largely does, too, but with some differences to allow for the fact that it supports duplicate keys.

In general, you’ll want to use the Dict module’s methods to access this functionality, as this allows you the flexibility to change the underlying implementation between, say, a map and a hashdict. (This example uses Enum.into, which is how you can easily map one kind of collection into another. We’ll look at this in The Collectable Protocol.)

maps/use_dict.exs

defmodule Sum do



def values(dict) do



dict |> Dict.values |> Enum.sum



end



end





# Sum a HashDict



hd = [ one: 1, two: 2, three: 3 ] |> Enum.into HashDict.new



IO.puts Sum.values(hd) # => 6





# Sum a Map



map = %{ four: 4, five: 5, six: 6 }



IO.puts Sum.values(map) # => 15





Let’s play with the Dict API:

iex> kw_list = [name: "Dave", likes: "Programming", where: "Dallas"]



[name: "Dave", likes: "Programming", where: "Dallas"]



iex> hashdict = Enum.into kw_list, HashDict.new



#HashDict<[name: "Dave", where: "Dallas", likes: "Programming"]>



iex> map = Enum.into kw_list, Map.new



%{likes: "Programming", name: "Dave", where: "Dallas"}



iex> kw_list[:name]



"Dave"



iex> hashdict[:likes]



"Programming"



iex> map[:where]



"Dallas"



iex> hashdict = Dict.drop(hashdict, [:where, :likes])



#HashDict<[name: "Dave"]>



iex> hashdict = Dict.put(hashdict, :also_likes, "Ruby")



#HashDict<[name: "Dave", also_likes: "Ruby"]>



iex> combo = Dict.merge(map, hashdict)



%{also_likes: "Ruby", likes: "Programming", name: "Dave", where: "Dallas"}





Keyword lists allow duplicate values, but you have to use the Keyword module to access them:

iex> kw_list = [name: "Dave", likes: "Programming", likes: "Elixir"]



[name: "Dave", likes: "Programming", likes: "Elixir"]



iex> kw_list[:likes]



"Programming"



iex> Dict.get(kw_list, :likes)



"Programming"



iex> Keyword.get_values(kw_list, :likes)



["Programming", "Elixir"]





As usual, the full API documentation is available online.[14] You owe it to yourself to spend some time getting familiar with it.





Pattern Matching and Updating Maps


The question we most often ask of our maps is, “Do you have the following keys (and maybe values)?”

Is there an entry with the key :name?

Are there entries for the keys :name and :height?

Does the entry with key :name have the value "Dave"?



Here’s how we ask these questions using Elixir patterns.

iex> person = %{ name: "Dave", height: 1.88 }



%{height: 1.88, name: "Dave"}



iex> %{ name: a_name } = person



%{height: 1.88, name: "Dave"}



iex> a_name



"Dave"



iex> %{ name: _, height: _ } = person



%{height: 1.88, name: "Dave"}



iex> %{ name: "Dave" } = person



%{height: 1.88, name: "Dave"}





Our map does not have the key :weight, so the following pattern match fails:

iex> %{ name: _, weight: _ } = person



** (MatchError) no match of right hand side value: %{height: 1.88, name: "Dave"}





It’s worth noting how the first pattern match destructured the map, extracting the value associated with the key :name. We can use this in many ways. Here’s one example—we can use destructuring in a list comprehension to give us a simple query capability.

maps/query.exs

people = [



%{ name: "Grumpy", height: 1.24 },



%{ name: "Dave", height: 1.88 },



%{ name: "Dopey", height: 1.32 },



%{ name: "Shaquille", height: 2.16 },



%{ name: "Sneezy", height: 1.28 }



]





for person = %{ height: height } <- people,



height > 1.5,



do: IO.inspect person





This produces

%{height: 1.88, name: "Dave"}



%{height: 2.16, name: "Shaquille"}





In this code, we feed a list of maps to our comprehension. The generator clause binds each map (as a whole) to person and binds the height from that map to height. The filter selects only those maps where the height exceeds 1.5, and the do block prints the whole map.

Clearly pattern matching is just pattern matching, so this maps capability works equally well in cond expressions, function head matching, and any other circumstances in which patterns are used.

maps/book_room.exs

defmodule HotelRoom do





def book(%{name: name, height: height})



when height > 1.9 do



IO.puts "Need extra long bed for #{name}"



end





def book(%{name: name, height: height})



when height < 1.3 do



IO.puts "Need low shower controls for #{name}"



end





def book(person) do



IO.puts "Need regular bed for #{person.name}"



end





end





people |> Enum.each(&HotelRoom.book/1)





#=> Need low shower controls for Grumpy



# Need regular bed for Dave



# Need regular bed for Dopey



# Need extra long bed for Shaquille



# Need low shower controls for Sneezy





Pattern Matching Can’t Bind Keys


Maps do not allow you to bind a value to a key during pattern matching. Thus, you can write this:

iex> %{ 2 => state } = %{ 1 => :ok, 2 => :error }



%{1 => :ok, 2 => :error}



iex> state



:error





but not this:

iex> %{ item => :ok } = %{ 1 => :ok, 2 => :error }



** (CompileError) iex:5: illegal use of variable item in map key





Updating a Map


In the previous chapter we saw how lists are updated through a combination of copying and changing the head.

With maps, we can add new key/value entries and update existing entries without traversing the whole structure. But as with all values in Elixir, a map is immutable, and so the result of the update is a new map.

The simplest way to update a map is with this syntax:

new_map = %{ old_map | key => value, … }





This creates a new map that is a copy of the old, but the values associated with the keys on the right of the pipe character are updated:

iex> m = %{ a: 1, b: 2, c: 3 }



%{a: 1, b: 2, c: 3}



iex> m1 = %{ m | b: "two", c: "three" }



%{a: 1, b: "two", c: "three"}



iex> m2 = %{ m1 | a: "one" }



%{a: "one", b: "two", c: "three"}





However, this syntax will not add a new key to a map. To do this, you have to use the Dict.put_new/3 function.





Maps and Structs


When Elixir sees %{ … } it knows it is looking at a map. But it doesn’t know much more than that. In particular, it doesn’t know what you intend to do with the map, whether only certain keys are allowed, or whether some keys should have default values.

That’s fine for anonymous maps. But what if we want to create a typed map—a map that has a fixed set of fields and default values for those fields, and that you can pattern-match by type as well as content.

Enter the struct.

A struct is simply a module that wraps a limited form of map. It’s limited because the keys must be atoms and because these maps don’t have Dict or Access capabilities.

The name of the module becomes the name of the map type. Inside the module, you use the defstruct macro to define the map’s characteristics.

maps/defstruct.exs

defmodule Subscriber do



defstruct name: "", paid: false, over_18: true



end





Let’s play with this in iex:

$ iex defstruct.exs



iex> s1 = %Subscriber{}



%Subscriber{name: "", over_18: true, paid: false}



iex> s2 = %Subscriber{ name: "Dave" }



%Subscriber{name: "Dave", over_18: true, paid: false}



iex> s3 = %Subscriber{ name: "Mary", paid: true }



%Subscriber{name: "Mary", over_18: true, paid: true}





The syntax for creating a struct is the same as the syntax for creating a map—you simply add the module name between the % and the {.

You access the fields in a struct using dot notation or pattern matching:

iex> s3.name



"Mary"



iex> %Subscriber{name: a_name} = s3



%Subscriber{name: "Mary", over_18: true, paid: true}



iex> a_name



"Mary"





And updates follow suit:

iex> s4 = %Subscriber{ s3 | name: "Marie"}



%Subscriber{name: "Marie", over_18: true, paid: true}





Why are structs wrapped in a module? The idea is that you are likely to want to add struct-specific behaviour.

maps/defstruct1.exs

defmodule Attendee do



defstruct name: "", paid: false, over_18: true





def may_attend_after_party(attendee = %Attendee{}) do



attendee.paid && attendee.over_18



end





def print_vip_badge(%Attendee{name: name}) when name != "" do



IO.puts "Very cheap badge for #{name}"



end





def print_vip_badge(%Attendee{}) do



raise "missing name for badge"



end



end





$ iex defstruct1.exs



iex> a1 = %Attendee{name: "Dave", over_18: true}



%Attendee{name: "Dave", over_18: true, paid: false}



iex> Attendee.may_attend_after_party(a1)



false



iex> a2 = %Attendee{a1 | paid: true}



%Attendee{name: "Dave", over_18: true, paid: true}



iex> Attendee.may_attend_after_party(a2)



true



iex> Attendee.print_vip_badge(a2)



Very cheap badge for Dave



:ok



iex> a3 = %Attendee{}



%Attendee{name: "", over_18: true, paid: false}



iex> Attendee.print_vip_badge(a3)



** (RuntimeError) missing name for badge



defstruct1.exs:13: Attendee.print_vip_badge/1





Notice how we could call the functions in the Attendee module to manipulate the associated struct.

Structs also play a large role when implementing polymorphism, which we’ll see when we look at protocols.





Another Way to Access Structs


The previous examples accessed struct attributes using dot notation. This might have surprised you, as structs and maps clearly have a lot in common and you access maps using some_map[:name].

The reason is that maps implement the Access protocol (which defines the ability to access fields using square-bracket notation) and structs do not. However, you can easily add this ability to your structs by using the @derive directive:

maps/derive.exs

defmodule Attendee do



@derive Access



defstruct name: "", over_18: false



end





$ iex derive.exs



iex> a = %Attendee{name: "Sally", over_18: true}



%Attendee{name: "Sally", over_18: true}



iex> a[:name]



"Sally"



iex> a[:over_18]



true



iex> a.name



"Sally"





Nested Dictionary Structures


The various dictionary types let us associate keys with values. But those values can themselves be dictionaries. For example, we may have a bug-reporting system in which customers report bugs. We could represent this using the following:

maps/nested.exs

defmodule Customer do



defstruct name: "", company: ""



end





defmodule BugReport do



defstruct owner: %{}, details: "", severity: 1



end





Let’s create a simple report:

iex> report = %BugReport{owner: %Customer{name: "Dave", company: "Pragmatic"},



...> details: "broken"}



%BugReport{details: "broken",



owner: %Customer{company: "Pragmatic", name: "Dave"},



severity: 1}





The owner attribute of the report is itself a Customer struct.

We can access nested fields using regular dot notation:

iex> report.owner.company



"Pragmatic"





But now our customer complains the company name is incorrect—it should be PragProg. Let’s fix it:

iex> report = %BugReport{ report | owner:



...> %Customer{ report.owner | company: "PragProg" }}



%BugReport{details: "broken",



owner: %Customer{company: "PragProg", name: "Dave"},



severity: 1}





That’s pretty ugly—we had to update the overall bug report’s owner attribute with an updated customer structure. This is verbose, hard to read, and error prone.

Fortunately, Elixir has a set of nested dictionary-access functions. One of these, put_in, lets us set a value in a nested structure:

iex> put_in(report.owner.company, "PragProg")



%BugReport{details: "broken",



owner: %Customer{company: "PragProg", name: "Dave"},



severity: 1}





This isn’t magic—it’s simply a macro that generates the long-winded code we’d have to have written otherwise.

The update_in function lets us apply a function to a value in a structure.

iex> update_in(report.owner.name, &("Mr. " <> &1))



%BugReport{details: "broken",



owner: %Customer{company: "PragProg", name: "Mr. Dave"},



severity: 1}





The other two nested access functions are get_in and get_and_update_in. The documentation in iex contains everything you need for these. However, both of these functions support a cool trick: nested access.





Nested Accessors and Nonstructs


The nested accessor functions use the Access protocol to strip apart and reassemble data structures. This means that if you are using maps or keyword lists, you can supply the keys as symbols:

iex> report = %{ owner: %{ name: "Dave", company: "Pragmatic" }, severity: 1}



%{owner: %{company: "Pragmatic", name: "Dave"}, severity: 1}



iex> put_in(report[:owner][:company], "PragProg")



%{owner: %{company: "PragProg", name: "Dave"}, severity: 1}



iex> update_in(report[:owner][:name], &("Mr. " <> &1))



%{owner: %{company: "Pragmatic", name: "Mr. Dave"}, severity: 1}





Dynamic (Runtime) Nested Accessors


The nested accessors we’ve seen so far are macros—they operate at compile time. As a result, they have some limitations:

The number of keys you pass a particular call is static.

You can’t pass the set of keys as parameters between functions.



These are a natural consequence of the way the macros bake their parameters into code at compile time.

To overcome this, get_in, put_in, update_in, and get_and_update_in can all take a list of keys as a separate parameter. Adding this parameter changes them from macros to function calls, so they become dynamic.



Macro

Function



get_in



no



(dict, keys)





put_in



(path, value)



(dict, keys, value)





update_in



(path, fn)



(dict, keys, fn)





get_and_update_in



(path, fn)



(dict, keys, fn)





Here’s a simple example:

maps/dynamic_nested.exs

nested = %{



buttercup: %{



actor: %{



first: "Robin",



last: "Wright"



},



role: "princess"



},



westley: %{



actor: %{



first: "Carey",



last: "Ewes" # typo!



},



role: "farm boy"



}



}





IO.inspect get_in(nested, [:buttercup])



# => %{actor: %{first: "Robin", last: "Wright"}, role: "princess"}





IO.inspect get_in(nested, [:buttercup, :actor])



# => %{first: "Robin", last: "Wright"}





IO.inspect get_in(nested, [:buttercup, :actor, :first])



# => "Robin"





IO.inspect put_in(nested, [:westley, :actor, :last], "Elwes")



# => %{buttercup: %{actor: %{first: "Robin", last: "Wright"}, role: "princess"},



# => westley: %{actor: %{first: "Carey", last: "Elwes"}, role: "farm boy"}}





There’s a cool trick that the dynamic versions of both get_in and get_and_update_in support—if you pass a function as a key, that function is invoked to return the corresponding values.

maps/get_in_func.exs

authors = [



%{ name: "José", language: "Elixir" },



%{ name: "Matz", language: "Ruby" },



%{ name: "Larry", language: "Perl" }



]





languages_with_an_r = fn (:get, collection, next_fn) ->



for row <- collection do



if String.contains?(row.language, "r") do



next_fn.(row)



end



end



end





IO.inspect get_in(authors, [languages_with_an_r, :name])



#=> [ "José", nil, "Larry" ]





Sets


There is currently just one implementation of sets, the HashSet.

iex> set1 = Enum.into 1..5, HashSet.new



#HashSet<[1, 2, 3, 4, 5]>



iex> Set.member? set1, 3



true



iex> set2 = Enum.into 3..8, HashSet.new



#HashSet<[3, 4, 5, 6, 7, 8]>



iex> Set.union set1, set2



#HashSet<[7, 6, 4, 1, 8, 2, 3, 5]>



iex> Set.difference set1, set2



#HashSet<[1, 2]>



iex> Set.difference set2, set1



#HashSet<[6, 7, 8]>



iex> Set.intersection set1, set2



#HashSet<[3, 4, 5]>





With Great Power Comes Great Temptation


The dictionary types are clearly a powerful tool—you’ll use them all the time. But you might also be tempted to abuse them. Structs in particular might lead you into the darkness because you can associate functions with them in their module definitions. At some point, the old object-orientation neurons still active in the nether regions of your brain might burst into life and you might think, “Hey, this is a bit like a class definition.” And you’d be right. You can write something akin to object-oriented code using structs (or maps) and modules.

This is a bad idea. Not because objects are intrinsically bad, but because you’ll be mixing paradigms and diluting the benefits a functional approach gives you.

Stay pure, young coder. Stay pure.

As a way of refocusing you away from the dark side, the next chapter is a mini diversion into the benefits of separating functions and the data they work on. And we disguise it in a discussion of types.





Footnotes


[13]

https://github.com/pragdave/map_performance



[14]

http://elixir-lang.org/docs/



