## 第十章 容器处理模块 Enum 和 Stream


本章内容：

* 枚举（Enum） 模块
* 流（Stream） 模块
* 容器（Collectable） 协议
* 列表解析（Comprehensions）


Elixir中又一些类型是容器类型。我们已经见过列表和字典。此外，还有范围（range），文件（file）、字典甚至是函数。当讨论协议的时候，将会学习如何自定义容器类型。

容器之间的实现各有差别。但是他们也有共同的一面：可以迭代。一些额外的功能：可以被扩展。

从技术角度说，类型能够被迭代的原理是因为它们实现了可枚举（Enumerable）的协议

Elixir提供了两个模块，包含了一些用于迭代的函数。Eunm模块作用于容器。你会经常使用。强烈建议学习。

Stream模块可以针对容器进行惰性（lazily）求值。这意味着，只有下一个元素被需要的时候才会计算。你不回一直使用他们，可是一点需要他们，必定能为你节省时间享受生活。

我不想把本书变成充满API文档的介绍手册。你可以在线阅读文档。我会通过阅读文档根据需呀插入内容，进行介绍这两个模块（记住，Elixir的强大一方面体现在他强大的库函数中）。


### Enum 处理容器

Enum几乎是Elixir中最常用的库。迭代，过滤，拼合，拆分等等容器炒作，都离不开它。下面是一些常用的介绍：

* 罢容器集合转换成列表：

```elixir
iex> list = Enum.to_list 1..5
[1, 2, 3, 4, 5]
```
* 拼合两个容器
```elixir
iex> Enum.concat([1,2,3], [4,5,6])
[1, 2, 3, 4, 5, 6]
iex> Enum.concat [1,2,3], 'abc'
[1, 2, 3, 97, 98, 99]
```

* 使用函数创建容器
```elixir
iex> Enum.map(list, &(&1 * 10))
[10, 20, 30, 40, 50]
iex> Enum.map(list, &String.duplicate("*", &1))
["*", "**", "***", "****", "*****"]
```

* 通过位置索引选择元素

```elixir
iex> Enum.at(10..20, 3)
13
iex> Enum.at(10..20, 20)
nil
iex> Enum.at(10..20, 20, :no_one_here)
:no_one_here
```

* 过滤：
```elixir
iex> Enum.filter(list, &(&1 > 2))
[3, 4, 5]
iex> Enum.filter(list, &Integer.is_even/1)
[2, 4]
iex> Enum.reject(list, &Integer.is_even/1)
[1, 3, 5]
```

* 排序

```elixir
iex> Enum.sort ["there", "was", "a", "crooked", "man"]
["a", "crooked", "man", "there", "was"]
iex> Enum.sort ["there", "was", "a", "crooked", "man"],
... &(String.length(&1) <= String.length(&2))
["a", "man", "was", "there", "crooked"]
iex(4)> Enum.max ["there", "was", "a", "crooked", "man"]
"was"
iex(5)> Enum.max_by ["there", "was", "a", "crooked", "man"], &String.length/1
"crooked"
```

* 拆分

```elixir
[1, 2, 3]
iex> Enum.take_every list, 2
[1, 3, 5]
iex> Enum.take_while(list, &(&1 < 4))
[1, 2, 3]
iex> Enum.split(list, 3)
{[1, 2, 3], [4, 5]}
iex> Enum.split_while(list, &(&1 < 4))
{[1, 2, 3], [4, 5]}
```

* 连接

```elixir
iex> Enum.join(list)
"12345"
iex> Enum.join(list, ", ")
"1, 2, 3, 4, 5"
```

* 判断

```elixir
iex> Enum.all?(list, &(&1 < 4))
false
iex> Enum.any?(list, &(&1 < 4))
true
iex> Enum.member?(list, 4)
true
iex> Enum.empty?(list)
false
```

* 分组归并

```elixir

iex> Enum.zip(list, [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]
iex> Enum.with_index(["once", "upon", "a", "time"])
[{"once", 0}, {"upon", 1}, {"a", 2}, {"time", 3}]
```

% reduce

```elixir

iex> Enum.reduce(1..100, &(&1+&2))
5050
iex> Enum.reduce(["now", "is", "the", "time"],fn word, longest ->
...> 	if String.length(word) > String.length(longest) do
...> 		word
...> 	else
...> 		longest
...> 	end
...> end)
"time"
iex> Enum.reduce(["now", "is", "the", "time"], 0, fn word, longest ->
...> 	if String.length(word) > longest do
...> 		String.length(word)
...> 	else
...> 		longest
...> 	end
...> end)
4
```

* 组合
```elixir
iex> import Enum
iex> deck = for rank <- '23456789TJQKA', suit <- 'CDHS', do: [suit,rank]
['C2', 'D2', 'H2', 'S2', 'C3', 'D3', ... ]
iex> deck |> shuffle |> take(13)
['DQ', 'S6', 'HJ', 'H4', 'C7', 'D6', 'SJ', 'S9', 'D7', 'HA', 'S4', 'C2', 'CT']
iex> hands = deck |> shuffle |> chunk(13)
[['D8', 'CQ', 'H2', 'H3', 'HK', 'H9', 'DK', 'S9', 'CT', 'ST', 'SK', 'D2', 'HA'],
['C5', 'S3', 'CK', 'HQ', 'D3', 'D4', 'CA', 'C8', 'S6', 'DQ', 'H5', 'S2', 'C4'],
['C7', 'C6', 'C2', 'D6', 'D7', 'SA', 'SQ', 'H8', 'DT', 'C3', 'H7', 'DA', 'HT'],
['S5', 'S4', 'C9', 'S8', 'D5', 'H4', 'S7', 'SJ', 'HJ', 'D9', 'DJ', 'CJ', 'H6']]
```

### 排序

排序使用sort函数

```elixir
Enum.sort(["once", "upon", "a", "time"],
&(String.length(&1) <= String.length(&2))
```

使用`<=`和`<`在排序中很有用。

### 流（Streams）-- 惰性迭代

Elixir的Enum模块是贪婪模式，传递给它一个容器的时候，它会把所有内容都载入内存。解释说会结果会是一个新的容器。例如：

enum/pipeline.exs

```elixir
[ 1, 2, 3, 4, 5 ]
|> Enum.map(&(&1*&1))
|> Enum.with_index
|> Enum.map(fn {value, index} -> value - index end)
|> IO.inspect #=> [1,3,7,13,21]
```


第一个`map`函数接受一个列表参数，并返回一个元素开方的新列表。`with_index`函数列表的索引元组。第二个map函数通过你们函数处理索引元组，最后生成的数据传给`IO.inspect`。

因此，管道的每一次操作输出结构的时候都生成了一次列表。

看看不同的处理方式，通过读一个文件，找出文件中最长的单词。


enum/longest_line.exs
```elixir
IO.puts File.read!("/usr/share/dict/words")
|> String.split
|> Enum.max_by(&String.length/1)
```

这种情况下，读文件的时候会把整个字典载入到内存（我的机器占用了2.4MB），然后在找出最长的单纯的时候需要拆分成字符列表（大概236,000个元素）

在这些例子中，我们调用代码，就会使用Enum模块，每一个从调用就载入一个容器，返回一个新的容器。

我们预期的方案是需要处理容器的元素才载入元素。无需最开始就把整个容器都载入内存。只需要把当前的元素从一个函数传入另外一个函数处理即可。是时候让`Streams`模块闪亮登场了。



### 流（Stream）是可组合的枚举器（Enumerator）

创建一个流：

```elixir
iex> s = Stream.map [1, 3, 5, 7], &(&1 + 1)
#Stream<[enum: [1, 3, 5, 7], funs: [#Function<37.75994740/1 in Stream.map/2>] ]>
```

如果调用`Enum.map`，会马上看见输出的结果`[2,4,6,8]`。调用Stream.map得到了一个流类型，可以看到原始的两个参数。

如何从流中开始计算真正的结果呢？只要把流看成是一个容器，然后传入Enum模块的函数处理就行了：


```elixir
iex> s = Stream.map [1, 3, 5, 7], &(&1 + 1)
#Stream<...>
iex> Enum.to_list s
[2, 4, 6, 8]
```

流也是可枚举的，同样也可以把流传给另外一个流的函数。因此，这种特性称之为可组装(`composable`)

```elixir
iex> squares = Stream.map [1, 2, 3, 4], &(&1*&1)
#Stream<[enum: [1, 2, 3, 4],
funs: [#Function<32.133702391 in Stream.map/2>] ]>
iex> plus_ones = Stream.map squares, &(&1+1)
#Stream<[enum: [1, 2, 3, 4],
funs: [#Function<32.133702391 in Stream.map/2>,
#Function<32.133702391 in Stream.map/2>] ]>
iex> odds = Stream.filter plus_ones, fn x -> rem(x,2) == 1 end
#Stream<[enum: [1, 2, 3, 4],
funs: [#Function<26.133702391 in Stream.filter/2>,
#Function<32.133702391 in Stream.map/2>,
#Function<32.133702391 in Stream.map/2>] ]>
iex> Enum.to_list odds
[5, 17]
```

当然，这样写：

enum/stream1.exs

```elixir
[1,2,3,4]
|> Stream.map(&(&1*&1))
|> Stream.map(&(&1+1))
|> Stream.filter(fn x -> rem(x,2) == 1 end)
|> Enum.to_list
```

注意了，我们并没有创建中间状态的列表，只是把容器的每一个元素都传入函数链中。前一个iex的会话给出了工作流的传递的函数链提示，可以看到流的元素被轮流的处理。

流不仅仅用来处理列表。Elixir的很多模块都支持流。例如，使用流实现我们找出**最大单词**：


enum/stream2.exs
```elixir
IO.puts File.open!("/usr/share/dict/words")
|> IO.stream(:line)
|> Enum.max_by(&String.length/1)
```

这里有一个神奇的方法`IO.stream`，他可以把IO设备的每一行数据转换成流。这个概念很有用，并且还可以简写：

enum/stream3.exs

```elixir
IO.puts File.stream!("/usr/share/dict/words") |> Enum.max_by(&String.length/1)
```
这样出来的的好处就是没有中间态的存储。不好的一面就是需要运行两次，比前一个例子稍慢。可是，考虑到从远程服务器或者其他传感器读取数据。连续的数据不会马上到来，甚至可能会持续到来。使用Enum实现的例子，我们不得不等待所有远程数据都到来才能处理。使用流则无需等待，数据以来就可以处理。可以来多少，处理多少。

### 无限流

流是惰性的，事情不需要准备所有容器的元素。例如：


```elixir
iex> Enum.map(1..10_000_000, &(&1+1)) |> Enum.take(5)
[2, 3, 4, 5, 6]
```
需要运行8秒才能看到结果。Elixir先创建一个包含1000千万个元素的列表，然后再处理前五个元素。如果换成流的版本：


```elixir
iex> Stream.map(1..10_000_000, &(&1+1)) |> Enum.take(5)
[2, 3, 4, 5, 6]
```

结果马上就返回了。因为后续处理只需要从流获取5个元素。一旦流产生了数据，马上就会被处理，没有延迟，处理完5个元素之后就返回了，没有多余的处理过程。

这些例子中流都是，流是是由边界的，但它同样可以很好永远持续，但是不要那么做。我们需要基于函数创建流。


### 自定义Streams

Streams are implemented solely in Elixir libraries—there is no specific runtime support. However, this doesn’t mean you want to drop down to the very lowest level and create your own streamable types. The actual implementation is complex (in the same way that string theory and dating rituals are complex). Instead, you probably want to use some helpful wrapper functions to do the heavy lifting. There are a number of these, including cycle, repeatedly, iterate, unfold, and resource. (If you needed proof that the internal implementation is tricky, consider the fact that these last two names give you almost no hint of their power.)

Let’s start with the three simplest: cycle, repeatedly, and iterate.

Stream.cycle


Stream.cycle takes an enumerable and returns an infinite stream containing that enumerable’s elements. When it gets to the end, it repeats from the beginning, indefinitely. Here’s an example that generates the rows in an HTML table with alternating green and white classes:

```elixir
iex> Stream.cycle(~w{ green white }) |>
...> Stream.zip(1..5) |>
...> Enum.map(fn {class, value} ->
...> ~s{<tr class="#{class}"><td>#{value}</td></tr>\n} end) |>
...> IO.puts
<tr class="green"><td>1</td></tr>
<tr class="white"><td>2</td></tr>
<tr class="green"><td>3</td></tr>
<tr class="white"><td>4</td></tr>
<tr class="green"><td>5</td></tr>
```

Stream.repeatedly


Stream.repeatedly takes a function and invokes it each time a new value is wanted.

```elixir
iex> Stream.repeatedly(fn -> true end) |> Enum.take(3)
[true, true, true]
iex> Stream.repeatedly(&:random.uniform/0) |> Enum.take(3)
[0.7230402056221108, 0.94581636451987, 0.5014907142064751]
```

Stream.iterate


Stream.iterate(start_value, next_fun) generates an infinite stream. The first value is start_value. The next value is generated by applying next_fun to this value. This continues for as long as the stream is being used, with each value being the result of applying next_fun to the previous value.

Here are some examples:

```elixir
iex> Stream.iterate(0, &(&1+1)) |> Enum.take(5)
[0, 1, 2, 3, 4]
iex> Stream.iterate(2, &(&1*&1)) |> Enum.take(5)
[2, 4, 16, 256, 65536]
iex> Stream.iterate([], &[&1]) |> Enum.take(5)
[[], [[]], [[[]]], [[[[]]]], [[[[[]]]]]]
```

Stream.unfold


Now we can get a little more adventurous. Stream.unfold is related to iterate, but you can be more explicit both about the values output to the stream and about the values passed to the next iteration. You supply an initial value and a function. The function uses the argument to create two values, returned as a tuple. The first is the value to be returned by this iteration of the stream, and the second is the value to be passed to the function on the next iteration of the stream. If the function returns nil, the stream terminates.

This sounds abstract, but unfold is quite useful—it is a general way of creating a potentially infinite stream of values where each value is some function of the previous state.

The key is the generating function. Its general form is

fn state -> { stream_value, new_state } end

For example, here’s a stream of Fibonacci numbers:

iex> Stream.unfold({0,1}, fn {f1,f2} -> {f1, {f2, f1+f2}} end) |> Enum.take(15)



[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]


Here the state is a tuple containing the current and the next number in the sequence. We seed it with the initial state of {0, 1}. The value each iteration of the stream returns is the first of the state values. The new state moves one down the sequence, so an initial state of {f1,f2} becomes a new state of {f2,f1+f2}.

Stream.resource


At this point you might be wondering how streams can interact with external resources. We’ve already seen how you can turn a file’s contents into a stream of lines, but how could you implement this yourself? You’d need to open the file when the stream first starts, return successive lines, and then close the file at the end. Or maybe you want to turn a database result-set cursor into a stream of values. You’d have to execute the query when the stream starts, return each row as stream values, and close the query at the end. And that’s where Stream.resource comes in.

Stream.resource builds upon Stream.unfold. It makes two changes.

The first argument to unfold is the initial value to be passed to the iteration function. But if that value is a resource, we don’t want to open it until the stream starts delivering values, and that might not happen until long after we create the stream. To get around this, resource takes not a value, but a function that returns the value. That’s the first change.

Second, when the stream is done with the resource, we may need to close it. That’s what the third argument to Stream.resource does—it takes the final accumulator value and does whatever is needed to deallocate the resource.

Here’s an example from the library documentation:

```elixir
Stream.resource(fn -> File.open("sample") end,
	fn file -> case IO.read(file, :line) do
			line when is_binary(line) -> { [line], file } _ -> {:halt, file}
		end
	end,
	fn file -> File.close!(file) end)
```


The first function opens the file when the stream becomes active, and passes it to the second function. This reads the file, line by line, returning either a line and the file as a tuple, or a :halt tuple at the end of the file. The third function closes the file.

Let’s finish with a different kind of resource: time. We’ll implement a timer that counts down the number of seconds until the start of the next minute. It uses a stream resource to do this. The allocation function returns the number of seconds left until the next minute starts. It does this each time the stream is evaluated, so we’ll get a countdown that varies depending on when it is called.

The iteration function looks at the time left. If zero, it returns {:halt, 0}; otherwise it sleeps for a second and returns the current countdown as a string, along with the decremented counter.

In this case there’s no resource deallocation, so the third function does nothing.

Here’s the code:

enum/countdown.exs

```elixir
defmodule Countdown do

	def sleep(seconds) do
		receive do
			after seconds*1000 -> nil
		end
	end

	def say(text) do
		spawn fn -> :os.cmd('say #{text}') end
	end

	def timer do

		Stream.resource(
			fn -> # the number of seconds to the start of the next minute

			{_h,_m,s} = :erlang.time 60 - s - 1
	end,

	fn # wait for the next second, then return its countdown

	0 -> :halt, 0}

	count ->

		sleep(1)
			{ [inspect(count)], count - 1 }
		end,

			fn _ -> end # nothing to deallocate
			)
	end

end
```


(The eagle-eyed among you will have noticed a function called say in the Countdown module. This executes the shell command say, which, on OS X, speaks its argument. You could substitute espeak on Linux and ptts on Windows.)

Let’s play with the code.

```elixir
$ iex countdown.exs
iex> counter = Countdown.timer
#Function<17.133702391 in Stream.resource/3>
iex> printer = counter |> Stream.each(&IO.puts/1)
#Stream[enum: #Function<17.133702391 in Stream.resource/3>,
funs: [#Function<0.133702391 in Stream.each/2>] ]>
iex> speaker = printer |> Stream.each(&Countdown.say/1)
#Stream[enum: #Function<17.133702391 in Stream.resource/3>,
funs: [#Function<0.133702391 in Stream.each/2>,
#Function<0.133702391 in Stream.each/2>] ]>
```




So far, we’ve built a stream that creates time events, prints the countdown value, and speaks it. But there’s been no output, as we haven’t yet asked the stream for any values. Let’s do that now:

```elixir
iex> speaker |> Enum.take(5)
37 ** numbers are output once
36 ** per second. Even cooler,the
35 ** computer says
34 ** "thirty seven", "thirty six"…
33
["37", "36", "35", "34", "33"]
```

Cool—we must have started it around 22 seconds into a minute, so the countdown starts at 37. Let’s use the same stream again, a few seconds later:

```elixir
iex> speaker |> Enum.take(5)
29
28
27
26
25
["29", "28", "27", "26", "25"]
```

Wait some more seconds, and this time let it run to the top of the minute:

```elixir
iex> speaker |> Enum.to_list
6
5
4
3
2
1
["6", "5", "4", "3","2", "1"]
```

This is clearly not great code, as it fails to correct the sleep time for any delays introduced by our code. But it illustrates a very cool point. Lazy streams let you deal with resources that are asynchronous to your code, and the fact that they are initialized every time they are used means they’re effectively side-effect-free. Every time we pipe our stream to an Enum function, we get a fresh set of values, computed at that time.


Streams in Practice


In the same way that functional programming requires you to look at problems in a new way, streams ask you to look at iteration and collections afresh. Not every situation where you are iterating requires a stream. But consider using a stream when you want to defer processing until you need the data, and when you need to deal with large numbers of things without necessarily generating them all at once.


### 容器（Collectable）协议


The Enumerable protocol lets you iterate over the elements in a type—given a collection, you can get the elements. Collectable is in some sense the opposite—it allows you to build a collection by inserting elements into it.

Not all collections are collectable. Ranges, for example, cannot have new entries added to them.

The collectable API is pretty low-level, so you’ll typically access it via Enum.into and when using comprehensions (which we cover in the next section). For example, we can inject the elements of a range into an empty list using
```elixir
iex> Enum.into 1..5, []
[1, 2, 3, 4, 5]
```

If the list is not empty, the new elements are tacked onto the end:

```elixir
iex> Enum.into 1..5, [100, 101 ]
[100, 101, 1, 2, 3, 4, 5]
```


Output streams are collectable, so the following code lazily copies standard input to standard output:

```elixir
iex> Enum.into IO.stream(:stdio, :line), IO.stream(:stdio, :line)
```

### 列表解析（Comprehensions）


When you’re writing functional code, you often map and filter collections of things. To make your life easier (and your code easier to read), Elixir provides a general-purpose shortcut for this: the comprehension.

The idea of a comprehension is fairly simple: given one or more collections, extract all combinations of values from each, optionally filter the values, and then generate a new collection using the values that remain.

The general syntax for comprehensions is deceptively simple:

result = for generator or filter… [, into: value ], do: expression

Let’s see a couple of basic examples before we get into the details.

```elixir
iex> for x <- [ 1, 2, 3, 4, 5 ], do: x * x
[1, 4, 9, 16, 25]
iex> for x <- [ 1, 2, 3, 4, 5 ], x < 4, do: x * x
[1, 4, 9]
```

A generator specifies how you want to extract values from a collection.

pattern <- list

Any variables matched in the pattern are available in the rest of the comprehension (including the block). For example, x <- [1,2,3] says that we want to first run the rest of the comprehension with x set to 1. Then we run it with x set to 2, and so on. If we have two generators, their operations are nested, so

x <- [1,2], y <- [5,6]

will run the rest of the comprehension with x=1, y=5; x=1, y=6; x=2, y=5; and x=2, y=6. We can use those values of x and y in the do block.

```elixir
iex> for x <- [1,2], y <- [5,6], do: x * y
[5, 6, 10, 12]
iex> for x <- [1,2], y <- [5,6], do: {x, y}
[{1, 5}, {1, 6}, {2, 5}, {2, 6}]
```

You can use variables from generators in later generators:

```elixir
iex> min_maxes = [{1,4}, {2,3}, {10, 15}]
[{1, 4}, {2, 3}, {10, 15}]
iex> for {min,max} <- min_maxes, n <- min..max, do: n
[1, 2, 3, 4, 2, 3, 10, 11, 12, 13, 14, 15]
```


A filter is a predicate. It acts as a gatekeeper for the rest of the comprehension—if the condition is false, then the comprehension moves on to the next iteration without generating an output value.

For example, the code that follows uses a comprehension to list pairs of numbers from 1 to 8 whose product is a multiple of 10. It uses two generators (to cycle through the pairs of numbers) and two filters. The first filter allows only pairs in which the first number is at least the value of the second. The second filter checks to see if the product is a multiple of 10.

```elixir
iex> first8 = [ 1,2,3,4,5,6,7,8 ]
[1, 2, 3, 4, 5, 6, 7, 8]
iex> for x <- first8, y <- first8, x >= y, rem(x*y, 10)==0, do: { x, y }
[{5, 2}, {5, 4}, {6, 5}, {8, 5}]
```

This comprehension iterates 64 times, with x=1, y=1; x=1, y=2; and so on. However, the first filter cuts the iteration short when x is less than y. This means the second filter runs only 36 times.

Because the first term in a generator is a pattern, we can use it to deconstruct structured data. Here’s a comprehension that swaps the keys and values in a keyword list.

```elixir
iex> reports = [ dallas: :hot, minneapolis: :cold, dc: :muggy, la: :smoggy ]
[dallas: :hot, minneapolis: :cold, dc: :muggy, la: :smoggy]
iex> for { city, weather } <- reports, do: { weather, city }
[hot: :dallas, cold: :minneapolis, muggy: :dc, smoggy: :la]
```


Comprehensions Work on Bits, Too


A bitstring (and, by extension, a binary or a string) is simply a collection of ones and zeroes. So it’s probably no surprise that comprehensions work bits, too. What might be surprising is the syntax:

```elixir
iex> for << ch <- "hello" >>, do: ch
'hello'
iex> for << ch <- "hello" >>, do: <<ch>>
["h", "e", "l", "l", "o"]
```

Here the generator is enclosed in << and >>, indicating a binary. In the first case, the do block returns the integer code for each character, so the resulting list is [104, 101, 108, 108, 111], which iex displays as 'hello'.

In the second case, we convert the code back into a string, and the result is a list of those one-character strings.

Again, the thing to the left of the <- is a pattern, and so we can use binary pattern matching. Let’s convert a string into the octal representation of its characters:

```elixir
iex> for << << b1::size(2), b2::size(3), b3::size(3) >> <- "hello" >>,
...> do: "0#{b1}#{b2}#{b3}"
["0150", "0145", "0154", "0154", "0157"]
```

Scoping and Comprehensions


All variable assignments inside a comprehension are local to that comprehension—you will not affect the value of a variable in the outer scope.
```elixir
iex> name = "Dave"
"Dave"
iex> for name <- [ "cat", "dog" ], do: String.upcase(name)
["CAT", "DOG"]
iex> name
"Dave"
iex>
```

### 列表解析返回值



In our examples so far, the comprehension has returned a list. The list contains the values returned by the do expression for each iteration of the comprehension.

This behavior can be changed with the into: parameter. This takes a collection that is to receive the results of the comprehension. For example, we can populate a map using

```elixir
iex> for x <- ~w{ cat dog }, into: %{}, do: { x, String.upcase(x) }
%{"cat" => "CAT", "dog" => "DOG"}
```

It might be more clear to use Map.new in this case:

```elixir
iex> for x <- ~w{ cat dog }, into: Map.new, do: { x, String.upcase(x) }

%{"cat" => "CAT", "dog" => "DOG"}
```

The collection doesn’t have to be empty:

```elixir
iex> for x <- ~w{ cat dog }, into: %{"ant" => "ANT"}, do: { x, String.upcase(x) }
%{"ant" => "ANT", "cat" => "CAT", "dog" => "DOG"}
```

In Chapter 22, Protocols—Polymorphic Functions, we’ll look at protocols, which let us specify common behaviors across different types. The into: option takes values that implement the Collectable protocol. These include lists, binaries, functions, maps, files, hash dicts, hash sets, and IO streams, so we can write things such as

```elixir
iex> for x <- ~w{ cat dog }, into: IO.stream(:stdio,:line), do: "<<#{x}>>\n"
<<cat>>
<<dog>>
%IO.Stream{device: :standard_io, line_or_bytes: :line, raw: false}
```

### 更快，超神


L. Peter Deutsch once penned, “To iterate is human, to recurse divine.” And that’s certainly the way I felt when I first started coding Elixir. The joy of pattern-matching lists in sets of recursive functions drove my designs. After a while, I realized that perhaps I was taking this too far.

In reality, most of our day-to-day work is better handled using the various enumerators built into Elixir. They make your code smaller, easier to understand, and probably more efficient.

Part of the process of learning to be effective in Elixir is working out for yourself when to use recursion and when to use enumerators. I recommend enumerating when you can.

Next we’ll look at string handling in Elixir (and Erlang).





