
## 第九章 何为类型


前面两章优先介绍了列表和字典的基础知识。也许你已经发现了，尽管我一直用类型来描述他们，但是，我真正想表达的却不是那样。

首先需要明确的就是原始的数据类型与自定义类型不一定相同，因为他们的表示可能不一样。

例如，一个原始的列表只是一些值的有序集合。我们可以使用中括号`[]`定义一个列表，也可以使用`|`操作符重构和新建一个列表。

在另外一层。`Elixir`还有`List`模块（类型），该模块提供了一些用于操作列表的函数。这些函数通常使用递归或者`|`操作符实现相关的功能。

我认为原始的列表和List模块的功能之间还是有差别的。原始的列表是一个数据结构的实现，而List模块则是在此之上的一个抽象。虽然实现了数据类型，但是这种类型是不同的。原始的列表并没有List模块的一些方法。

> 这段话主要想表达，自定义的模块也可以看成是自己创建了一种数据结构，即数据类型。但是这个类型和语言内建的类型是由差别的，虽然他们的功能上可能差不多。；例如`List`是一个模块，同时也是列表类型，但是这个列表和是用`[]`字面量定义的列表还是有差别的。大概就是字面量的列表属于语言层面，即原始类型（内建类型）。`List`模块属于用户层面，即用户可以自己自定义一个`List`类型，用于实现相关列表的功能。

图也是原始的数据类型。与类别类似，`Elixir`也提供另一个丰富的基于图的模块（类型）。

`Keyword`类型也是`Elxiir`的模块，当时它使基于内建的列表和元组实现的：

```elixir
options = [ {:width, 72}, {:style, "light"}, {:style, "print"} ]
```
注意关键字列表本质还是一个列表，所有适用列表的函数都适用关键字列表。但是，`Elixir`提供了这个类型一下字典行为的功能。

```elixir
iex> options = [ {:width, 72}, {:style, "light"}, {:style, "print"} ]
[width: 72, style: "light", style: "print"]
iex> List.last options
{:style, "print"}
iex> Keyword.get_values options, :style
["light", "print"]
```

总而言之，这样的情况就类型我们在面对对象动态语言中讨论的[鸭子类型](http://en.wikipedia.org/wiki/Duck_typing)（`duck typing`）一样（看起来像样子，行为也是鸭子的行为，那么就可以认为是鸭子）。`Keyword`模块（类型）并不是内建的数据类型。它简单地假定它适用于任何数值都是被某种方式结构化的列表。

> 这段话可以理解为，`Keyword`是一个列表，具有列表的功能。同时它又有字典结构的功能，当使用它的字典行为功能的时候，可以把它看成是一个字典。也就是说，他其实是一个列表，但是实现了一些字典的行为，它的类型像是动态的。


这意味着`Elxiir`中的容器集合`API`将会相当广泛。使用关键字列表的 时候，可以当成内建的列表来使用，也可以使用List或者`Keyword`模块提供的方法。当然还可以使用Enum和`Collectable`模块方法，下一章将会介绍。
