
第十二章 流程控制


本章内容：

* if 和 unless 语句
* cond（多分支if）语句
* case（switch模式匹配）语句
* 异常

我们已经长时间探索了Elixir。到目前为止，还没有出现过if语句，或者任何看起来像流程控制的语句。

情况挺不错。Elixir可以让我们写短小的函数，联合卫语句喝参数的模式匹配可以实现其他语言中的流程控制。

Elixir代码尝试接近声明式语言，但不是必须的。


Elixir也有流程控制结构。我之所以迟迟不介绍是因为我觉得尽量不使用它们。你应该明确的放弃使用代码中的if或者case语句。思考更多函数式的方案。如果你不使用严格的控制结构来书写函数的好处是显而易见，你代码将会更精炼，更易读，更易测试和重用。如果你的Elixir代码有10行或者20行才写完一个函数。可以肯定需要使用本章的一些结构知识来作简化。


### if 和 unless 语句


Elixir中，if和它的好基友unless语句，它们都接受两个参数：条件表达式和关键字列表。键是 do:和 else:。如果条件表达式为真值，则会执行分支键do:的值，否则则计算分支键else:的值。没有其他的分支了。

```elixir
iex> if 1 == 1, do: "true part", else: "false part"
"true part"
iex> if 1 == 2, do: "true part", else: "false part"
"false part"
```

本质是函数，但是Elixir提供了语法糖（syntactic sugar）。可以这么写：

```elixir
iex> if 1 == 1 do
...> "true part"
...> else
...> "false part"
...> end
true part
```

unless语句也类似:

```elixir
iex> unless 1 == 1, do: "error", else: "OK"
"OK"
iex> unless 1 == 2, do: "OK", else: "error"
"OK"
iex> unless 1 == 2 do
...> "OK"
...> else
...> "error"
...> end
"OK"
```

### cond 宏

cond 宏可以让你列出一些条件表达式，每一个表达式都可以联系一个分支的代码。当遇到表达式求值为真的时候，分支的代码将会被展开。

FizzBuzz有些，孩纸们会从一开始数数。如果数到3的倍数，就需要说“Fizz.”。如果是5的倍数，就需要说“Buzz.”。3或者5共同的倍数则需要说“FizzBuzz.”。其他情况就直接说数到的数。

用elixir实现：

control/fizzbuzz.ex

```elixir

defmodule FizzBuzz do

	def upto(n) when n > 0, do: _upto(1, n, [])
	
	defp _upto(_current, 0, result), do: Enum.reverse result

	defp _upto(current, left, result) do
		
		next_answer = cond do
				rem(current, 3) == 0 and rem(current, 5) == 0 -> "FizzBuzz"
				rem(current, 3) == 0 -> "Fizz"
				rem(current, 5) == 0 ->  "Buzz"
				rue -> current
			end

		_upto(current+1, left-1, [ next_answer | result ])

	end
end
```

首先，看代码的cond语句哪一行。我们把cond表达式的返回的结果绑定给变了next_answer。在cond语句块内，条件语句中变量current分别和3，5取余。Elixir会依次检测条件语句，如果条件表达式的值为真，则会执行->后面的语句。_upto函数递归的执行以便找出下一个值。注意->后面的语句，如果之前的条件已经符合返回真了，那么后面的语句将不会被执行，这一点和传统的case不太一样。

还有一个小问题。

There’s a minor problem, though. The result list we build always has the most recent value as its head. When we finish, we’ll end up with a list that has the answers in reverse order. That’s why in the anchor case (when left is zero), we reverse the result before returning it. This is a very common pattern. And don’t worry about performance—list reversal is highly optimized.


打开iex测试：

```elixir
iex> c("fizzbuzz.ex")
[FizzBuzz]
iex> FizzBuzz.upto(20)
[1, 2, "Fizz", 4, "Buzz", "Fizz", 7, 8, "Fizz", "Buzz", 11, "Fizz",
.. 13, 14, "FizzBuzz", 16, 17, "Fizz", 19, "Buzz"]
```


In this case, we could do something different and remove the call to reverse. If we process the numbers in reverse order (so we start at n and end at 1), the resulting list will be in the correct order.

control/fizzbuzz1.ex

```elixir
defmodule FizzBuzz do

	def upto(n) when n > 0, do: _downto(n, [])

	defp _downto(0, result), do: result

	defp _downto(current, result) do

		next_answer = cond do
					rem(current, 3) == 0 and rem(current, 5) == 0 -> "FizzBuzz"
					rem(current, 3) == 0 -> "Fizz"
					rem(current, 5) == 0 -> "Buzz"
					true -> current
				end

		_downto(current-1, [ next_answer | result ])
	end
end
```


This code is quite a bit cleaner than the previous version. However, it is also slightly less idiomatic—readers will expect to traverse the numbers in a natural order and reverse the result.

But there’s a third option. The FizzBuzz code transforms a number into some value. Where possible, we like to code things as transformations. We can use Enum.map to transform the range of numbers from 1 to n to the corresponding FizzBuzz values.

control/fizzbuzz2.ex

```elixir
defmodule FizzBuzz do

	def upto(n) when n > 0 do

		1..n |> Enum.map(&fizzbuzz/1)
	end

	defp fizzbuzz(n) do

		cond do

			rem(n, 3) == 0 and rem(n, 5) == 0 -> "FizzBuzz"
			rem(n, 3) == 0 -> "Fizz"
			rem(n, 5) == 0 -> "Buzz"
			true -> n
		end
	end
end
```



This section is intended to show you how cond works, but you’ll often find that it’s better not to use it, and instead to take advantage of pattern matching in function calls:

control/fizzbuzz3.ex

```elixir
defmodule FizzBuzz do

	def upto(n) when n > 0 do

		1..n |> Enum.map(&fizzbuzz/1)
	end

	defp fizzbuzz(n) when rem(n, 3) == 0 and rem(n, 5) == 0, do: "FizzBuzz"

	defp fizzbuzz(n) when rem(n, 3) == 0, do: "Fizz"

	defp fizzbuzz(n) when rem(n, 5) == 0, do: "Buzz"

	defp fizzbuzz(n), do: n
end
```

选择由你。

### case 语句

case将一个值与许多模式进行比较，直到找到一个匹配的，返回匹配条件之后的代码执行结果。模式匹配也可以使用卫语句。

例如：File.open函数返回两个元素的元组。如果打开成功，返回{:ok, file}，file是文件标示符。如果打开失败，返回{:error, reason}。这种情况下使用case语句就很合适。

control/case.ex

```elixir
case File.open("case.ex") do

	{ :ok, file } -> IO.puts "First line: #{IO.read(file, :line)}"

	{ :error, reason } -> IO.puts "Failed to open file: #{reason}"
end
```

处理结果:

第一行: `case File.open("case.ex") do`


If we change the file name to something that doesn’t exist and then rerun the code, we get

Failed to open file: enoent


We can use the full power of nested pattern matches:

control/case1.exs

```elixir
defmodule Users do

	dave = %{ name: "Dave", state: "TX", likes: "programming" }
	case dave do

		%{state: some_state} = person -> IO.puts "#{person.name} lives in #{some_state}"
		_ -> IO.puts "No matches"
	end

end
```

We’ve seen how to employ guard clauses to refine the pattern used when matching functions. We can do the same with case.

control/case2.exs

```elixir
defmodule Bouncer do

	dave = %{name: "Dave", age: 27}

	case dave do

		person = %{age: age} when is_number(age) and age >= 21 -> IO.puts "You are cleared to enter the Foo Bar, #{person.name}"

		_ -> IO.puts "Sorry, no admission"
	end
end
```

### 异常

First, the official warning: exceptions in Elixir are not control-flow structures. Instead, Elixir exceptions are intended for things that should never happen in normal operation. That means the database going down or a name server failing to respond could be considered exceptional. Failing to open a configuration file whose name is fixed could be seen as exceptional. However, failing to open a file whose name a user entered is not. (You could anticipate that a user might mistype it every now and then.)

Raise an exception with the raise function. At its simplest, you pass it a string and it generates an exception of type RuntimeError.
```elixir
iex> raise "Giving up"
** (RuntimeError) Giving up
```




You can also pass the type of the exception, along with other optional attributes. All exceptions implement at least the message attribute.
```elixir
iex> raise RuntimeError
** (RuntimeError) runtime error
iex> raise RuntimeError, message: "override message"
** (RuntimeError) override message
```




You use exceptions far less in Elixir than in other languages—the design philosophy is that errors should propagate back up to an external, supervising process. We’ll cover this when we talk about OTP Supervisors.

Elixir has all the usual exception-catching mechanisms. To emphasize how little you should use them, I’ve described them in an appendix.





Designing with Exceptions


If File.open succeeds, it returns {:ok, file}, where file is the service that gives you access to the file. If it fails, it returns {:error, reason}. So, for code that knows a file open might not succeed and that wants to handle the fact, you might write

```elixir
case File.open(user_file_name) do

	{:ok, file} -> process(file)

	{:error, message} -> IO.puts :stderr, "Couldn't open #{user_file_name}: #{message}"

end
```




If instead you expect the file to open successfully every time, you could raise an exception on failure.

```elixir
case File.open("config_file") do 
	
	{:ok, file} -> process(file)
	{:error, message} -> raise "Failed to open config file: #{message}"
end
```




Or you could let Elixir raise an exception for you and write

{ :ok, file } = File.open("config_file")



process(file)


If the pattern match on the first line fails, Elixir will raise a MatchError exception. It won’t be as informative as our version that handled the error explicitly, but if the error should never happen, this form is probably good enough (at least until it triggers the first time and the operations folks say they’d like more information).

An even better way to handle this is to use File.open!. The trailing exclamation point in the method name is an Elixir convention—if you see it, you know the function will raise an exception on error, and that exception will be meaningful. So we could simply write

file = File.open!("config_file")

and get on with our lives.


Doing More with Less


Elixir has just a few forms of control flow: if, unless, cond, case, and (perhaps) raise. But surprisingly, this doesn’t matter in practice. Elixir programs are rich and expressive without a lot of branching code. And they’re easier to work with as a result.

That concludes our basic tour of Elixir. Now let’s start putting it all together and implement a full project.







