
第十二章 流程控制


本章内容：

* if 和 unless 语句
* cond（多分支if）语句
* case（switch模式匹配）语句
* 异常

我们已经长时间探索了Elixir。到目前为止，还没有出现过if语句，或者任何看起来像流程控制的语句。

情况挺不错。Elixir可以让我们写短小的函数，联合卫语句喝参数的模式匹配可以实现其他语言中的流程控制。

Elixir代码尝试接近声明式语言，但不是必须的。


Elixir也有流程控制结构。我之所以迟迟不介绍是因为我觉得尽量不使用它们。你应该明确的放弃使用代码中的if或者case语句。思考更多函数式的方案。如果你不使用严格的控制结构来书写函数的好处是显而易见，你代码将会更精炼，更易读，更易测试和重用。如果你的Elixir代码有10行或者20行才写完一个函数。可以肯定需要使用本章的一些结构知识来作简化。


### if 和 unless 语句


Elixir中，if和它的好基友unless语句，它们都接受两个参数：条件表达式和关键字列表。键是 do:和 else:。如果条件表达式为真值，则会执行分支键do:的值，否则则计算分支键else:的值。没有其他的分支了。

```elixir
iex> if 1 == 1, do: "true part", else: "false part"
"true part"
iex> if 1 == 2, do: "true part", else: "false part"
"false part"
```

本质是函数，但是Elixir提供了语法糖（syntactic sugar）。可以这么写：

```elixir
iex> if 1 == 1 do
...> "true part"
...> else
...> "false part"
...> end
true part
```

unless语句也类似:

```elixir
iex> unless 1 == 1, do: "error", else: "OK"
"OK"
iex> unless 1 == 2, do: "OK", else: "error"
"OK"
iex> unless 1 == 2 do
...> "OK"
...> else
...> "error"
...> end
"OK"
```

### cond 语句


The cond macro lets you list out a series of conditions, each with associated code. It executes the code corresponding to the first truthy conditions.

In the game of FizzBuzz, children count up from 1. If the number is a multiple of three, they say “Fizz.” For multiples of five, they say “Buzz.” For multiples of both, they say “FizzBuzz.” Otherwise, they say the number.

In Elixir, we could code this as follows:

control/fizzbuzz.ex

Line 1defmodule FizzBuzz do



-



- def upto(n) when n > 0, do: _upto(1, n, [])



-



5 defp _upto(_current, 0, result), do: Enum.reverse result



-



- defp _upto(current, left, result) do



- next_answer =



- cond do



10 rem(current, 3) == 0 and rem(current, 5) == 0 ->



- "FizzBuzz"



- rem(current, 3) == 0 ->



- "Fizz"



- rem(current, 5) == 0 ->



15 "Buzz"



- true ->



- current



- end



- _upto(current+1, left-1, [ next_answer | result ])



20 end



- end





First, look at the use of cond starting on line 8. We assign the value of the cond expression to next_answer. Inside the cond, we have four alternatives—the current number is a multiple of 3 and 5, just 3, just 5, or neither. Elixir examines each in turn and returns the value of the expression following the -> for the first true one. The _upto function then recurses to find the next value. Also note the use of true -> to handle the case where none of the previous conditions match. This is the equivalent of the else or default stanza of a more traditional case statement.

There’s a minor problem, though. The result list we build always has the most recent value as its head. When we finish, we’ll end up with a list that has the answers in reverse order. That’s why in the anchor case (when left is zero), we reverse the result before returning it. This is a very common pattern. And don’t worry about performance—list reversal is highly optimized.

Let’s try the code in iex:

iex> c("fizzbuzz.ex")



[FizzBuzz]



iex> FizzBuzz.upto(20)



[1, 2, "Fizz", 4, "Buzz", "Fizz", 7, 8, "Fizz", "Buzz", 11, "Fizz",



.. 13, 14, "FizzBuzz", 16, 17, "Fizz", 19, "Buzz"]





In this case, we could do something different and remove the call to reverse. If we process the numbers in reverse order (so we start at n and end at 1), the resulting list will be in the correct order.

control/fizzbuzz1.ex

defmodule FizzBuzz do





def upto(n) when n > 0, do: _downto(n, [])





defp _downto(0, result), do: result



defp _downto(current, result) do



next_answer =



cond do



rem(current, 3) == 0 and rem(current, 5) == 0 ->



"FizzBuzz"



rem(current, 3) == 0 ->



"Fizz"



rem(current, 5) == 0 ->



"Buzz"



true ->



current



end



_downto(current-1, [ next_answer | result ])



end



end





This code is quite a bit cleaner than the previous version. However, it is also slightly less idiomatic—readers will expect to traverse the numbers in a natural order and reverse the result.

But there’s a third option. The FizzBuzz code transforms a number into some value. Where possible, we like to code things as transformations. We can use Enum.map to transform the range of numbers from 1 to n to the corresponding FizzBuzz values.

control/fizzbuzz2.ex

defmodule FizzBuzz do



def upto(n) when n > 0 do



1..n |> Enum.map(&fizzbuzz/1)



end





defp fizzbuzz(n) do



cond do



rem(n, 3) == 0 and rem(n, 5) == 0 ->



"FizzBuzz"



rem(n, 3) == 0 ->



"Fizz"



rem(n, 5) == 0 ->



"Buzz"



true ->



n



end



end



end





This section is intended to show you how cond works, but you’ll often find that it’s better not to use it, and instead to take advantage of pattern matching in function calls:

control/fizzbuzz3.ex

defmodule FizzBuzz do



def upto(n) when n > 0 do



1..n |> Enum.map(&fizzbuzz/1)



end





defp fizzbuzz(n) when rem(n, 3) == 0 and rem(n, 5) == 0, do: "FizzBuzz"



defp fizzbuzz(n) when rem(n, 3) == 0, do: "Fizz"



defp fizzbuzz(n) when rem(n, 5) == 0, do: "Buzz"



defp fizzbuzz(n), do: n



end





The choice is yours.





case


case lets you test a value against a set of patterns, executes the code associated with the first one that matches, and returns the value of that code. The patterns may include guard clauses.

For example, the File.open function returns a two-element tuple. If the open is successful, it returns {:ok, file}, where file is an identifier for the open file. If the open fails, it returns {:error, reason}. We can use case to take the appropriate action when we open a file. (In this case the code opens its own source file.)

control/case.ex

case File.open("case.ex") do



{ :ok, file } ->



IO.puts "First line: #{IO.read(file, :line)}"



{ :error, reason } ->



IO.puts "Failed to open file: #{reason}"



end





produces:

First line: case File.open("case.ex") do





If we change the file name to something that doesn’t exist and then rerun the code, we get

Failed to open file: enoent





We can use the full power of nested pattern matches:

control/case1.exs

defmodule Users do



dave = %{ name: "Dave", state: "TX", likes: "programming" }





case dave do



%{state: some_state} = person ->



IO.puts "#{person.name} lives in #{some_state}"





_ ->



IO.puts "No matches"



end



end





We’ve seen how to employ guard clauses to refine the pattern used when matching functions. We can do the same with case.

control/case2.exs

defmodule Bouncer do





dave = %{name: "Dave", age: 27}





case dave do



person = %{age: age} when is_number(age) and age >= 21 ->



IO.puts "You are cleared to enter the Foo Bar, #{person.name}"





_ ->



IO.puts "Sorry, no admission"



end



end





Raising Exceptions


First, the official warning: exceptions in Elixir are not control-flow structures. Instead, Elixir exceptions are intended for things that should never happen in normal operation. That means the database going down or a name server failing to respond could be considered exceptional. Failing to open a configuration file whose name is fixed could be seen as exceptional. However, failing to open a file whose name a user entered is not. (You could anticipate that a user might mistype it every now and then.)

Raise an exception with the raise function. At its simplest, you pass it a string and it generates an exception of type RuntimeError.

iex> raise "Giving up"



** (RuntimeError) Giving up





You can also pass the type of the exception, along with other optional attributes. All exceptions implement at least the message attribute.

iex> raise RuntimeError



** (RuntimeError) runtime error



iex> raise RuntimeError, message: "override message"



** (RuntimeError) override message





You use exceptions far less in Elixir than in other languages—the design philosophy is that errors should propagate back up to an external, supervising process. We’ll cover this when we talk about OTP Supervisors.

Elixir has all the usual exception-catching mechanisms. To emphasize how little you should use them, I’ve described them in an appendix.





Designing with Exceptions


If File.open succeeds, it returns {:ok, file}, where file is the service that gives you access to the file. If it fails, it returns {:error, reason}. So, for code that knows a file open might not succeed and that wants to handle the fact, you might write

case File.open(user_file_name) do



{:ok, file} ->



process(file)



{:error, message} ->



IO.puts :stderr, "Couldn't open #{user_file_name}: #{message}"



end





If instead you expect the file to open successfully every time, you could raise an exception on failure.

case File.open("config_file") do



{:ok, file} ->



process(file)



{:error, message} ->



raise "Failed to open config file: #{message}"



end





Or you could let Elixir raise an exception for you and write

{ :ok, file } = File.open("config_file")



process(file)





If the pattern match on the first line fails, Elixir will raise a MatchError exception. It won’t be as informative as our version that handled the error explicitly, but if the error should never happen, this form is probably good enough (at least until it triggers the first time and the operations folks say they’d like more information).

An even better way to handle this is to use File.open!. The trailing exclamation point in the method name is an Elixir convention—if you see it, you know the function will raise an exception on error, and that exception will be meaningful. So we could simply write

file = File.open!("config_file")





and get on with our lives.





Doing More with Less


Elixir has just a few forms of control flow: if, unless, cond, case, and (perhaps) raise. But surprisingly, this doesn’t matter in practice. Elixir programs are rich and expressive without a lot of branching code. And they’re easier to work with as a result.

That concludes our basic tour of Elixir. Now let’s start putting it all together and implement a full project.





Your Turn


Exercise: ControlFlow-1

Rewrite the FizzBuzz example using case.



Exercise: ControlFlow-2

We now have three different implementations of FizzBuzz. One uses cond, one uses case, and one uses separate functions with guard clauses.

Take a minute to look at all three. Which do you feel best expresses the problem. Which will be easiest to maintain?

The case style and the implementation using guard clauses are different from control structures in most other languages. If you feel that one of these was the best implementation, can you think of ways to remind yourself to investigate these options as you write Elixir code in the future?



Exercise: ControlFlow-3

Many built-in functions have two forms. The xxx form returns the tuple {:ok, data} and the xxx! form returns data on success but raises an exception otherwise. However, some functions don’t have the xxx! form.

Write an ok! function that takes an arbitrary parameter. If the parameter is the tuple {:ok, data}, return the data. Otherwise, raise an exception containing information from the parameter.

You could use your function like this: file = ok! File.open("somefile")



