

Chapter 13





Organizing a Project




* * *



In this chapter, we’ll see

Project structure

The mix build tool

ExUnit testing framework

DocTests



Let’s stop hacking and get serious.

You’ll want to organize your source code, write tests, and handle any dependencies. And you’ll want to follow Elixir conventions, because that way you’ll get support from the tools.

In this chapter we’ll look at mix, the Elixir build tool. We’ll investigate the directory structure it uses and see how to manage external dependencies. And we’ll end up using ExUnit to write tests for our code (and to validate the examples in our code’s documentation). To motivate this, we’ll write a tool that downloads and lists the n oldest issues from a GitHub project. Along the way, we’ll need to find some libraries and make some design decisions typical of an Elixir project. We’ll call our project issues.





The Project: Fetch Issues from GitHub


GitHub provides a nice web API for fetching issues.[18] Simply issue a GET request to

https://api.github.com/repos/user/project/issues





and you’ll get back a JSON list of issues. We’ll reformat this, sort it, and filter out the oldest n, presenting the result as a table:

# | created_at | title



----+----------------------+-----------------------------------------



889 | 2013-03-16T22:03:13Z | MIX_PATH environment variable (of sorts)



892 | 2013-03-20T19:22:07Z | Enhanced mix test --cover



893 | 2013-03-21T06:23:00Z | mix test time reports



898 | 2013-03-23T19:19:08Z | Add mix compile --warnings-as-errors





How Our Code Will Do It


Our program will run from the command line. We’ll need to pass in a GitHub user name, a project name, and an optional count. This means we’ll need some basic command-line parsing.

We’ll need to access GitHub as an HTTP client, so we’ll have to find a library that gives us the client side of HTTP. The response that comes back will be in JSON, so we’ll need a library that handles JSON, too. We’ll need to be able to sort the resulting structure. And finally, we’ll need to lay out selected fields in a table.

We can think of this data transformation in terms of a production line. Raw data enters at one end and is transformed by each of the stations in turn.



Here we see data, starting at command line and ending at pretty table. At each stage, it undergoes a transformation (parse, fetch, and so on). These transformations are the functions we write. We’ll cover each one in turn.





Task: Use Mix to Create Our New Project


Mix is a command-line utility that manages Elixir projects. Use it to create new projects, manage a project’s dependencies, run tests, and run your code. If you have Elixir installed, you also have mix. Try running it now:

$ mix help



mix # Run the default task (current: mix run)



mix archive # List all archives



mix archive.build # Archive this project into a .ez file



: : : :



mix new # Create a new Elixir project



mix run # Run the given file or expression



mix test # Run a project's tests



iex -S mix # Start IEx and run the default task





This is a list of the standard tasks that come with mix. (Your list may be a little different, depending on your version of Elixir.) For more information on a particular task, use mix help taskname.

$ mix help deps





List all dependencies and their status.





Dependencies must be specified in the `mix.exs` file in one of



the following formats:



. . .





You can also write your own mix tasks, both for a project and to share between projects.[19]





Create the Project Tree


Each Elixir project lives in its own directory tree. If you use mix to manage this tree, then you’ll need to follow the mix conventions (which are also the conventions of the Elixir community). We’ll use these conventions in the rest of this chapter.

We’ll call our project issues, so it will go in a directory named issues. We’ll create this directory using mix.

At the command line, navigate to a place where you want this new project to live, and type

$ mix new issues



* creating README.md



: :



* creating test



* creating test/test_helper.exs



* creating test/issues_test.exs





Your mix project was created successfully.



You can use mix to compile it, test it, and more:





cd issues



mix test





Run `mix help` for more commands.





In tree form, the newly created files and directories look like this:

issues



.gitignore



README.md



config



config.exs



lib



issues.ex



mix.exs



test



issues_test.exs



test_helper.exs





Change into the issues/ directory. This is a good time to set up version control. I use Git, so I do

$ git init



$ git add .



$ git commit -m "Initial commit of new project"





(I don’t want to clutter the book with version-control stuff, so that’s the last time I’ll mention it. Make sure you follow your own version-control practices as we go along.)

Our new project contains three directories and seven files.

.gitignore

Lists the files and directories generated as by-products of the build and not to be saved in the repository.



README.md

A place to put a description of your project (in Markdown format). If you store your project on GitHub, this file’s contents will appear on the project’s home page.



config/

Eventually we’ll put some application-specific configuration here.



lib/

This is where our project’s source lives. Mix has already added a top-level module (issues.ex in our case).



mix.exs

This source file contains our project’s configuration options. We will be adding stuff to this as our project progresses.



test/

A place to store our tests. Mix has already created a helper file and a stub for unit tests of the issues module.



Now our job is to add our code. But before we do, let’s think a little about the implementation.





Transformation: Parse the Command Line


Let’s start with the command line. We really don’t want to couple the handling of command-line options into the main body of our program, so let’s write a separate module to interface between what the user types and what our program does. By convention this module is called Project.CLI (so our code would be in Issues.CLI). Also by convention, the main entry point to this module will be a function called run that takes an array of command-line arguments.

Where should we put this module?

Elixir has a convention. Inside the lib/ directory, create a subdirectory with the same name as the project (so we’d create the directory lib/issues/). This directory will contain the main source for our application, one module per file. And each module will be namespaced inside the Issues module—the module naming follows the directory naming.

In this case, the module we want to write is Issues.CLI—it is the CLI module nested inside the Issues module. Let’s reflect that in the directory structure and put cli.ex in the lib/issues directory:

lib



issues



cli.ex



issues.ex





Elixir comes bundled with an option-parsing library,[20] so we will use that. We’ll tell it that -h and --help are possible switches, and anything else is an argument. It returns a tuple, where the first element is a keyword list of the options and the second is a list of the remaining arguments. Our initial CLI module looks like the following.

project/0/issues/lib/issues/cli.ex

defmodule Issues.CLI do





@default_count 4





@moduledoc """



Handle the command line parsing and the dispatch to



the various functions that end up generating a



table of the last _n_ issues in a github project



"""





def run(argv) do



parse_args(argv)



end





@doc """



`argv` can be -h or --help, which returns :help.





Otherwise it is a github user name, project name, and (optionally)



the number of entries to format.





Return a tuple of `{ user, project, count }`, or `:help` if help was given.



"""



def parse_args(argv) do



parse = OptionParser.parse(argv, switches: [ help: :boolean],



aliases: [ h: :help ])



case parse do





{ [ help: true ], _, _ }



-> :help





{ _, [ user, project, count ], _ }



-> { user, project, count }





{ _, [ user, project ], _ }



-> { user, project, @default_count }





_ -> :help





end



end



end





Step: Write Some Basic Tests


At this point, I get a little nervous if I don’t have some tests. Fortunately, Elixir comes with a wonderful (and simple) testing framework called ExUnit.

Have a look at the file test/issues_test.exs.

project/0/issues/test/issues_test.exs

defmodule IssuesTest do



use ExUnit.Case





test "the truth" do



assert(true)



end



end





It acts as a template for all the test files you write. I just copy and paste the boilerplate into separate test files as I need them. So let’s write tests for our CLI module, putting those tests into the file test/cli_test.exs. We’ll test that the option parser successfully detects the -h and --help options, and that it returns the arguments otherwise. We’ll also check that it supplies a default value for the count if only two arguments are given.

project/1/issues/test/cli_test.exs

defmodule CliTest do



use ExUnit.Case





import Issues.CLI, only: [ parse_args: 1 ]





test ":help returned by option parsing with -h and --help options" do



assert parse_args(["-h", "anything"]) == :help



assert parse_args(["--help", "anything"]) == :help



end





test "three values returned if three given" do



assert parse_args(["user", "project", "99"]) == { "user", "project", 99 }



end





test "count is defaulted if two values given" do



assert parse_args(["user", "project"]) == { "user", "project", 4 }



end



end





These tests all use the basic assert macro that ExUnit provides. This macro is clever—if an assertion fails, it can extract the values from the expression you pass it, giving you a nice error message.

To run our tests, we’ll use the mix test task.

issues % mix test



Compiled lib/issues.ex



Compiled lib/issues/cli.ex



Generated issues.app



..





Failures:





1) test three values returned if three given (CliTest)



Assertion with == failed



code: Issues.CLI.parse_args(["user", "project", "99"]) ==



{"user", "project", 99}



lhs: {"user", "project", "99"}



rhs: {"user", "project", 99}



test/cli_test.exs:10



.



Finished in 0.01 seconds



4 tests, 1 failures





Three of the four tests ran successfully. However, when we pass a count as the third parameter, it blows up. See how the assertion shows you its type (== in this case), the line of code that failed, and the two values that we compared. You can see the difference between the left-hand side (lhs), which is the value returned by parse_args, and the expected value (the rhs). We were expecting to get a number as the count, but we got a string.

That’s easily fixed. The built-in function String.to_integer converts a binary (a string) into an integer.

project/1/issues/lib/issues/cli.ex

def parse_args(argv) do



parse = OptionParser.parse(argv, switches: [ help: :boolean],



aliases: [ h: :help ])



case parse do





{ [ help: true ], _, _ } -> :help



» { _, [ user, project, count ], _ } -> { user, project, String.to_integer(count) }



{ _, [ user, project ], _ } -> { user, project, @default_count }



_ -> :help



end



end





Your Turn


Exercise: OrganizingAProject-1

Do what I did. Honest. Create the project and write and test the option parser. It’s one thing to read about it, but you’ll be doing this a lot, so you may as well start now.





Transformation: Fetch from GitHub


Now let’s continue down our data-transformation chain. Having parsed our arguments, we need to transform them by fetching data from GitHub. So we’ll extend our run function to call a process function, passing it the value returned from the parse_args function. We could have written this:

process(parse_args(argv))





But to understand this code, you have to read it right to left. I prefer to make the chain more explicit using the Elixir pipe operator:

project/1/issues/lib/issues/cli.ex

def run(argv) do



argv



|> parse_args



|> process



end





We need two variants of the process function. One handles the case where the user asked for help and parse_args returned :help. The second handles the case where a user, project, and count are returned.

project/1/issues/lib/issues/cli.ex

def process(:help) do



IO.puts """



usage: issues <user> <project> [ count | #{@default_count} ]



"""



System.halt(0)



end





def process({user, project, _count}) do



Issues.GithubIssues.fetch(user, project)



end





We can use mix to run our function. Let’s first see if help gets displayed.

$ mix run -e 'Issues.CLI.run(["-h"])'



usage: issues <user> <project> [ count | 4 ]





You pass mix run an Elixir expression, which gets evaluated in the context of your application. Mix will recompile your application, as it is out of date before executing the expression.

If we pass it user and project names, however, it’ll blow up because we haven’t written that code yet.

% mix run -e 'Issues.CLI.run(["elixir-lang", "elixir"])'



** (UndefinedFunctionError) undefined function: Issues.GithubIssues.fetch/2



GithubIssues.fetch("elixir-lang", "elixir")





Let’s write that code now. Our program will act as an HTTP client, accessing GitHub through its web API. So, it looks like we’ll need an external library.





Task: Use External Libraries


If you come from a world with a single accepted package-management system (such as Ruby with its gems), you’ll be disappointed by the lack of something similar in the Elixir world. But remember: it’s early days. There were no drive-throughs on the frontier.

At the same time, I think you’ll be pleasantly surprised at how easy it is to integrate libraries into your project once you find them.





Finding a Library


The first port of call is http://elixir-lang.org/docs/, the Elixir documentation. Often you’ll find a built-in library that does what you want.

Next, check if any standard Erlang libraries do what you need. This isn’t a simple task. Visit http://erlang.org/doc/ and look in the left sidebar for Application Groups. There you’ll find libraries sorted by top-level category.

If you find what you’re looking for in either of these two places, you can stop, because all these libraries are already available to your application. But if they don’t have what you need, you’ll have to add an external dependency.

The next place to look is http://hex.pm, the Elixir/Erlang Package Manager. This is a (small, but growing) list of packages that integrate nicely with a mix-based project.

If all else fails, Google and GitHub are your friends. Search for terms such as elixir http client or erlang distributed logger, and you’re likely to turn up the libraries you need.

In our case, we need an HTTP client. We find that Elixir has nothing built in, but hex.pm has a number of HTTP client libraries.

To me, HTTPoison looks like a good option. So how do we include it in our project?





Adding a Library to Your Project


Mix takes the view that all external libraries should be copied into the project’s directory structure. The good news is that it handles all this for us—we just need to list the dependencies, and it does the rest. Remember the mix.exs file at the top level of our project?

project/0/issues/mix.exs

defmodule Issues.Mixfile do



use Mix.Project





def project do



[ app: :issues,



version: "0.0.1",



elixir: ">= 0.0.0",



deps: deps ]



end





# Configuration for the OTP application



# Type `mix help compile.app` for more information



def application do



[applications: [:logger]]



end





# Returns the list of dependencies in the format:



# { :foobar, git: "https://github.com/elixir-lang/foobar.git", tag: "0.1" }



#



# To specify particular versions, regardless of the tag, do:



# { :barbat, "~> 0.1", github: "elixir-lang/barbat.git" }



defp deps do



[]



end



end





We add new dependencies to the deps function. As the project is in hex.pm, that’s very straightforward. We just give the name and the version we want.

project/1/issues/mix.exs

defp deps do



[



{ :httpoison, "~> 0.4" }



]



end





In this case, we give the version as "~> 0.3". This matches any version of HTTPoison with a major version of 0 and a minor version of 3 or greater. In iex, type h Version for more details.

Once your mix.exs file is updated, you’re ready to have mix manage your dependencies.

Use mix deps to list the dependencies and their status:

$ mix deps



* httpoison (package)



the dependency is not available, run `mix deps.get`





Download the dependencies with mix deps.get:

$ mix deps.get



Running dependency resolution



Unlocked: httpoison



Dependency resolution completed successfully



httpoison: v0.3.0



* Getting httpoison (package)



Fetching package (http://s3.hex.pm/tarballs/httpoison-0.3.0.tar)



Unpacked package tarball (/Users/dave/.hex/packages/httpoison-0.3.0.tar)



==> httpoison





Run mix deps again:

$ mix deps



==> httpoison



==> issues



* httpoison (package)



locked at 0.3.0



the dependency build is outdated, please run `mix deps.compile`





This shows that the HTTPoison library is installed but that it hasn’t yet been compiled. Mix also remembers the Git hash of each library it installs (it stores them in the file mix.lock). This means that at any point in the future you can get the exact version of the library you use now.

We don’t worry that the library isn’t compiled—mix will automatically compile it the first time we need it.

If you look at your project tree, you’ll find a new directory called deps containing your dependencies. Note that these dependencies are themselves just projects, so you can browse their source and read their documentation.





Your Turn


Exercise: OrganizingAProject-2

Add the dependency to your project and install it.





Back to the Transformation


So, back to our problem. We have to write the function GithubIssues.fetch, which transforms a user name and project into a data structure containing that project’s issues. The HTTPoison page on GitHub gives us a clue,[21] and we write a new module, Issues.GithubIssues:

project/1/issues/lib/issues/github_issues.ex

defmodule Issues.GithubIssues do



@user_agent [ {"User-agent", "Elixir dave@pragprog.com"} ]





def fetch(user, project) do



issues_url(user, project)



|> HTTPoison.get(@user_agent)



|> handle_response



end



def issues_url(user, project) do



"https://api.github.com/repos/#{user}/#{project}/issues"



end



def handle_response(%{status_code: 200, body: body}), do: { :ok, body }



def handle_response(%{status_code: ___, body: body}), do: { :error, body }



end





We simply call get on the GitHub URL. (We also have to pass in a user-agent header to keep the GitHub API happy.) What comes back is a structure. If we have a successful response, we return a tuple whose first element is :ok, along with the body. Otherwise we return an :error tuple, also with the body.

But there’s one more thing. If you look at the HTTPoison GitHub page, you’ll see that the example code calls HTTPoison.start. That’s because HTTPoison actually runs as a separate application, outside your main process. A lot of developers will copy this code, calling start inline like this. (I did myself, until José Valim set me straight.) But there’s a better way. Back in our mix.exs file, there’s a function called application.

project/0/issues/mix.exs

# Configuration for the OTP application



# Type `mix help compile.app` for more information



def application do



[applications: [:logger]]



end





OTP is the framework that manages suites of running applications. The application function configures the contents of these suites. By default, this app function starts the Elixir logger. But we can use it to start extra applications. We tell mix about starting HTTPoison here. (I found this counterintuitive at first. Erlang—and, by extension, Elixir—programs are often structured as suites of cooperating subapplications. Frequently, the code that would be a library in another language is a subapplication in Elixir. It might help to think of these as components or services.)

project/1/issues/mix.exs

def application do



[ applications: [ :logger, :httpoison ] ]



end





Don’t worry about the details here—we’ll be talking about this extensively in Part II of this book.

We can play with this in iex. Use the -S mix option to run mix before dropping into interaction mode. Because this is the first time we’ve tried to run our code since installing the dependencies, you’ll see them get compiled:

$ iex -S mix



Erlang/OTP 17 [erts-6.0] [source] [64-bit] [smp:4:4] [async-threads:10]



[hipe] [kernel-poll:false] [dtrace]





==> idna (compile)



Compiled src/idna_ucs.erl



Compiled src/idna.erl



: :



Compiled lib/issues/cli.ex



Generated issues.app





iex(1)>





Let’s try it out:

iex> Issues.GithubIssues.fetch("elixir-lang", "elixir")



{:ok,



"[{"url":"https://api.github.com/repos/elixir-lang/elixir/issues/970",



labels_url":"https://api.github.com/repos/elixir-lang/elixir/issues/970



/labels{/name}","comments_url":"https://api.github.com/repos/elixir-lang/



elixir/issues/970/comments","events_url":"https://api.github.com/repos/



elixir-lang/elixir/issues/970/events", …



{"html_url":null,"diff_url":null,"patch_url":null},"body":""}]





This is the body of the Git response. It’s a tuple with the first element set to :ok. The second element is a single long string containing the data encoded in JSON format.





Transformation: Convert Response


We’ll need a JSON library to convert the response into a data structure. Searching hex.pm, I found the Erlang library jsx,[22] so let’s add its dependency to our mix.exs file.

project/2/issues/mix.exs

defp deps do



[



{ :httpoison, "~> 0.4" },



{ :jsx, "~> 2.0" }



]



end





Run mix deps.get, and you’ll end up with jsx installed.

To convert the body from a string, we call the jsx decode function when we return the message from the GitHub API:

project/3/issues/lib/issues/github_issues.ex

def handle_response(%{status_code: 200, body: body}) do



» { :ok, :jsx.decode(body) }



end





def handle_response(%{status_code: ___, body: body}) do



» { :error, :jsx.decode(body) }



end





We also have to deal with a possible error response from the fetch, so back in the CLI module we write a function that decodes the body and returns it on a success response; the function extracts the error from the body and displays it otherwise.

def process({user, project, _count}) do



Issues.GithubIssues.fetch(user, project)



» |> decode_response



end





def decode_response({:ok, body}), do: body





def decode_response({:error, error}) do



{_, message} = List.keyfind(error, "message", 0)



IO.puts "Error fetching from Github: #{message}"



System.halt(2)



end





The JSON that GitHub returns for a successful response is a list with one element per GitHub issue. That element is itself a list of key/value tuples. To make these easier (and more efficient) to work with, we’ll convert our list of lists into a list of Elixir hashdicts, which give you fast access by key to a list of key/value pairs.[23]

We’ll do that by piping our data through this function:

def convert_to_list_of_hashdicts(list) do



list



|> Enum.map(&Enum.into(&1, HashDict.new))



end





* * *





Dependencies That Aren't in Hex




* * *



The dependencies you need are likely in hex, so mix will probably find them automatically. However, sometimes you’ll need to go further afield. The good news is that mix can also load dependencies from other sources. The most common is GitHub.



For example, hackney was added to hex only toward the end of my writing this book. In earlier versions of the text, I had to add the following dependency to my mix.exs:



def deps do



[ { . . . },



{ :hackney, github: "benoitc/hackney" }



]



end





* * *





Application Configuration


Before we move on, there’s one little tweak I’d like to make. The issues_url function hardcodes the GitHub URL. Let’s make this configurable.

Remember that when we created the project using mix new, it added a config/ directory containing config.exs. That file stores application-level configuration.

It should start with the line

use Mix.Config





We then write configuration information for each of the applications in our project. Here we’re configuring the Issues application, so we write the following code.

project/3/issues/config/config.exs

use Mix.Config



config :issues, github_url: "https://api.github.com"





Each config line adds one or more key/value pairs to the given application’s _environment. If you have multiple lines for the same application, they accumulate, with duplicate keys in later lines overriding values from earlier ones.

In our code, we use the Application.get_env function to return a value from the environment.

project/3/issues/lib/issues/github_issues.ex

# use a module attribute to fetch the value at compile time



@github_url Application.get_env(:issues, :github_url)





def issues_url(user, project) do



"#{@github_url}/repos/#{user}/#{project}/issues"



end





Because the application environment is commonly used in Erlang code, you’ll find yourself using the configuration facility to configure code you import, as well as code you write.

Sometimes you may want to vary the configuration, perhaps depending on your application’s environment. One way is to use the import_config function, which reads configuration from a file. If your config.exs contains

use Mix.Config





import_config "#{Mix.env}.exs"





then Elixir will read dev.exs, test.exs, or prod.exs, depending on your environment.

You can override the default config file name (config/config.exs) using the --config option to elixir.





Transformation: Sort Data


Look at our original “design.”





We’re making good progress—we’ve coded all of the top conveyor belt. Our next transformation is to sort the data on its created_at field. And this can just use a standard Elixir library function, sort/2. We could create a new module for this, but it would be pretty lonely. For now we’ll put the function in the CLI module and keep an eye out for opportunities to move it out if we add related functions later.

So now our CLI module contains

def process({user, project, count}) do



Issues.GithubIssues.fetch(user, project)



|> decode_response



|> convert_to_list_of_hashdicts



» |> sort_into_ascending_order



end





def sort_into_ascending_order(list_of_issues) do



Enum.sort list_of_issues,



fn i1, i2 -> i1["created_at"] <= i2["created_at"] end



end





That sort_into_ascending_order function worries me a little—I get the comparison the wrong way around about 50% of the time, so let’s write a little CLI test.

project/3/issues/test/cli_test.exs

test "sort ascending orders the correct way" do



result = sort_into_ascending_order(fake_created_at_list(["c", "a", "b"]))



issues = for issue <- result, do: issue["created_at"]



assert issues == ~w{a b c}



end





defp fake_created_at_list(values) do



data = for value <- values,



do: [{"created_at", value}, {"other_data", "xxx"} ]



convert_to_list_of_hashdicts data



end





Update the import line at the top of the test:

import Issues.CLI, only: [ parse_args: 1,



sort_into_ascending_order: 1,



convert_to_list_of_hashdicts: 1 ]





and run it:

$ mix test



.....



Finished in 0.00 seconds



5 tests, 0 failures





Lookin’ fine.





Transformation: Take First n Items


Our next transformation is to extract the first count entries from the list. Rather than write a function, we’ll use the built-in Enum.take:

def process({user, project, count}) do



Issues.GithubIssues.fetch(user, project)



|> decode_response



|> convert_to_list_of_hashdicts



|> sort_into_ascending_order



» |> Enum.take(count)



end





Your Turn


Exercise: OrganizingAProject-3

Bring your version of this project in line with the code here.



Exercise: OrganizingAProject-4

(Tricky) Before reading the next section, see if you can write the code to format the data into columns, like the sample output at the start of the chapter. This is probably the longest piece of Elixir code you’ll have written. Try to do it without using if or cond.





Transformation: Format the Table


All that’s left from our design is to create the formatted table. This would be a nice interface:

def process({user, project, count}) do



Issues.GithubIssues.fetch(user, project)



|> decode_response



|> convert_to_list_of_hashdicts



|> sort_into_ascending_order



|> Enum.take(count)



» |> print_table_for_columns(["number", "created_at", "title"])



end





We pass the formatter the list of columns to include in the table, and it writes the table to standard output.

The formatter doesn’t add any new project- or design-related techniques, so we’ll just list it.

project/4/issues/lib/issues/table_formatter.ex

defmodule Issues.TableFormatter do





import Enum, only: [ each: 2, map: 2, map_join: 3, max: 1 ]





def print_table_for_columns(rows, headers) do



data_by_columns = split_into_columns(rows, headers)



column_widths = widths_of(data_by_columns)



format = format_for(column_widths)





puts_one_line_in_columns headers, format



IO.puts separator(column_widths)



puts_in_columns data_by_columns, format



end





def split_into_columns(rows, headers) do



for header <- headers do



for row <- rows, do: printable(row[header])



end



end





def printable(str) when is_binary(str), do: str



def printable(str), do: to_string(str)





def widths_of(columns) do



for column <- columns, do: column |> map(&String.length/1) |> max



end





def format_for(column_widths) do



map_join(column_widths, " | ", fn width -> "~-#{width}s" end) <> "~n"



end





def separator(column_widths) do



map_join(column_widths, "-+-", fn width -> List.duplicate("-", width) end)



end





def puts_in_columns(data_by_columns, format) do



data_by_columns



|> List.zip



|> map(&Tuple.to_list/1)



|> each(&puts_one_line_in_columns(&1, format))



end





def puts_one_line_in_columns(fields, format) do



:io.format(format, fields)



end





end





And here are the tests for it.

project/4/issues/test/table_formatter_test.exs

defmodule TableFormatterTest do



use ExUnit.Case # bring in the test functionality



import ExUnit.CaptureIO # And allow us to capture stuff sent to stdout





alias Issues.TableFormatter, as: TF





def simple_test_data do



[ [ c1: "r1 c1", c2: "r1 c2", c3: "r1 c3", c4: "r1+++c4" ],



[ c1: "r2 c1", c2: "r2 c2", c3: "r2 c3", c4: "r2 c4" ],



[ c1: "r3 c1", c2: "r3 c2", c3: "r3 c3", c4: "r3 c4" ],



[ c1: "r4 c1", c2: "r4++c2", c3: "r4 c3", c4: "r4 c4" ] ]



end





def headers, do: [ :c1, :c2, :c4 ]





def split_with_three_columns,



do: TF.split_into_columns(simple_test_data, headers)





test "split_into_columns" do



columns = split_with_three_columns



assert length(columns) == length(headers)



assert List.first(columns) == ["r1 c1", "r2 c1", "r3 c1", "r4 c1"]



assert List.last(columns) == ["r1+++c4", "r2 c4", "r3 c4", "r4 c4"]



end





test "column_widths" do



widths = TF.widths_of(split_with_three_columns)



assert widths == [ 5, 6, 7 ]



end





test "correct format string returned" do



assert TF.format_for([9, 10, 11]) == "~-9s | ~-10s | ~-11s~n"



end





test "Output is correct" do



result = capture_io fn ->



TF.print_table_for_columns(simple_test_data, headers)



end



assert result == """



c1 | c2 | c4



------+--------+--------



r1 c1 | r1 c2 | r1+++c4



r2 c1 | r2 c2 | r2 c4



r3 c1 | r3 c2 | r3 c4



r4 c1 | r4++c2 | r4 c4



"""



end



end





Rather than clutter the process function in the CLI module with a long module name, I chose to use import to make the print function available without a module qualifier. This goes near the top of cli.ex.

import Issues.TableFormatter, only: [ print_table_for_columns: 2 ]





This code also uses a wonderful Elixir testing feature. By importing ExUnit.CaptureIO, we get access to the capture_io function. This runs the code passed to it, but captures anything written to standard output, returning it as a string.





Task: Make a Command-Line Executable


Although we can run our code by calling the run function via mix, it isn’t really friendly for other users. So let’s create something we can run from the command line.

Mix can package our code, along with its dependencies, into a single file that can be run on any Unix-based platform. This uses Erlang’s escript utility, which can run precompiled programs stored as a Zip archive. In our case, the program will be run as issues.

When escript runs a program, it looks in your mix.exs file for the option escript. This should return a keyword list of escript configuration settings. The most important of these is main_module:, which must be set to the name of a module containing a main function. It passes the command-line arguments to this main function as a list of character lists (not binaries). As this seems to be a command-line concern, we’ll put the main function in Issues.CLI. Here’s the update to mix.exs:

project/4/issues/mix.exs

defmodule Issues.Mixfile do



use Mix.Project





def project do



[ app: :issues,



version: "0.0.1",



elixir: ">= 0.0.0",



» escript: escript_config,



deps: deps ]



end





# Configuration for the OTP application



def application do



[



applications: [ :logger, :httpoison, :jsx ]



]



end





defp deps do



[



{ :httpoison, "~> 0.4" },



{ :jsx, "~> 2.0" }



]



end





» defp escript_config do



» [ main_module: Issues.CLI ]



» end



end





Now let’s add a main function to our CLI. In fact, all we need to do is rename the existing run function:

project/4/issues/lib/issues/cli.ex

def main(argv) do



argv



|> parse_args



|> process



end





Then we package our program using mix:

$ mix escript.build



Generated escript issues





Now we can run the app locally. We can also send it to a friend—it will run on any computer that has Erlang installed.

$ ./issues dynamo dynamo 3



nu | created_at | title



---+----------------------+----------------------------------------------



7 | 2012-09-15T10:48:11Z | Should have a websocket demo ?



45 | 2013-02-23T14:40:56Z | Raise an error if a layout can't be found.



46 | 2013-02-24T21:42:23Z | Force mix dynamo CamelCase to raise exception





Task: Add Some Logging


Imagine a large Elixir application—dozens of processes potentially running across a number of nodes. You’d really want a standard way to keep track of significant events as it runs. Enter the Elixir logger.

The default mix.exs starts the logger for your application.

project/5/issues/mix.exs

def application do



[



applications: [ :logger, :httpoison, :jsx ]



]



end





The logger supports four levels of message—in increasing order of severity they are debug, info, warn, and error. You select the level of logging in two ways.

First, you can determine at compile time the minimum level of logging to include. Logging below this level is not even compiled into your code. The compile-time level is set in the config/config.exs file:

project/5/issues/config/config.exs

use Mix.Config



config :issues, github_url: "https://api.github.com"



» config :logger, compile_time_purge_level: :info





Next, you can change the minimum log level at runtime by calling Logger.configure. (Clearly, this cannot enable log levels that you excluded at compile time.)

After all this configuration, it’s time to add some logging.

The basic logging functions are Logger.debug, .info, .warn, and .error. Each function takes either a string or a zero-arity function:

Logger.debug "Order total #{total(order)}"



Logger.debug fn -> "Order total #{total(order)}" end





Why have the function version? Perhaps the calculation of the order total is expensive. In the first version, we’ll always call it to interpolate the value into our string, even if the runtime log level is set to ignore debug-level messages. In the function variant, though, the total function will be invoked only if the log message is needed.

Anyway, here’s a version of our fetch function with some logging:

project/5/issues/lib/issues/github_issues.ex

defmodule Issues.GithubIssues do





» require Logger





@user_agent [ {"User-agent", "Elixir dave@pragprog.com"} ]





def fetch(user, project) do



» Logger.info "Fetching user #{user}'s project #{project}"



issues_url(user, project)



|> HTTPoison.get(@user_agent)



|> handle_response



end





def handle_response(%{status_code: 200, body: body}) do



» Logger.info "Successful response"



» Logger.debug fn -> inspect(body) end



{ :ok, :jsx.decode(body) }



end





def handle_response(%{status_code: status, body: body}) do



» Logger.error "Error #{status} returned"



{ :error, :jsx.decode(body) }



end





# use a module attribute to fetch the value at compile time



@github_url Application.get_env(:issues, :github_url)





def issues_url(user, project) do



"#{@github_url}/repos/#{user}/#{project}/issues"



end





end





Note the use of require Logger at the top of the module. If you forget this (and I do every time), you’ll get an error when you make the first call to Logger.

We can play with the new code in iex:

iex> Issues.CLI.process {"elixir-lang", "elixir", 1}



21:58:27.577 [info] Fetching user elixir-lang's project elixir



21:58:28.175 [info] Successful response



numb | created_at | title



-----+----------------------+-----------------------------------------------



2396 | 2014-06-12T15:02:23Z | Elixir version checking for installed archives



:ok





Notice that the debug-level message is not displayed.





Task: Test the Comments


When I document my functions, I like to include examples of the function being used—comments saying things such as, “Feed it these arguments, and you’ll get this result.” In the Elixir world, a common way to do this is to show the function being used in an iex session.

Here’s an example. Our TableFormatter holds a number of self-contained functions that we can document.

project/5/issues/lib/issues/table_formatter.ex

defmodule Issues.TableFormatter do





import Enum, only: [ each: 2, map: 2, map_join: 3, max: 1 ]





@doc """



Takes a list of row data, where each row is a HashDict, and a list of



headers. Prints a table to STDOUT of the data from each row



identified by each header. That is, each header identifies a column,



and those columns are extracted and printed from the rows.





We calculate the width of each column to fit the longest element



in that column.



"""



def print_table_for_columns(rows, headers) do



data_by_columns = split_into_columns(rows, headers)



column_widths = widths_of(data_by_columns)



format = format_for(column_widths)





puts_one_line_in_columns headers, format



IO.puts separator(column_widths)



puts_in_columns data_by_columns, format



end





@doc """



Given a list of rows, where each row contains a keyed list



of columns, return a list containing lists of the data in



each column. The `headers` parameter contains the



list of columns to extract





## Example





iex> list = [Enum.into([{"a", "1"},{"b", "2"},{"c", "3"}], HashDict.new),



...> Enum.into([{"a", "4"},{"b", "5"},{"c", "6"}], HashDict.new)]



iex> Issues.TableFormatter.split_into_columns(list, [ "a", "b", "c" ])



[ ["1", "4"], ["2", "5"], ["3", "6"] ]





"""



def split_into_columns(rows, headers) do



for header <- headers do



for row <- rows, do: printable(row[header])



end



end





@doc """



Return a binary (string) version of our parameter.



## Examples



iex> Issues.TableFormatter.printable("a")



"a"



iex> Issues.TableFormatter.printable(99)



"99"



"""



def printable(str) when is_binary(str), do: str



def printable(str), do: to_string(str)





@doc """



Given a list containing sublists, where each sublist contains the data for



a column, return a list containing the maximum width of each column





## Example



iex> data = [ [ "cat", "wombat", "elk"], ["mongoose", "ant", "gnu"]]



iex> Issues.TableFormatter.widths_of(data)



[ 6, 8 ]



"""



def widths_of(columns) do



for column <- columns, do: column |> map(&String.length/1) |> max



end





@doc """



Return a format string that hard codes the widths of a set of columns.



We put `" | "` between each column.





## Example



iex> widths = [5,6,99]



iex> Issues.TableFormatter.format_for(widths)



"~-5s | ~-6s | ~-99s~n"



"""



def format_for(column_widths) do



map_join(column_widths, " | ", fn width -> "~-#{width}s" end) <> "~n"



end





@doc """



Generate the line that goes below the column headings. It is a string of



hyphens, with + signs where the vertical bar between the columns goes.





## Example



iex> widths = [5,6,9]



iex> Issues.TableFormatter.separator(widths)



"------+--------+----------"



"""



def separator(column_widths) do



map_join(column_widths, "-+-", fn width -> List.duplicate("-", width) end)



end





@doc """



Given a list containing rows of data, a list containing the header selectors,



and a format string, write the extracted data under control of the format string.



"""



def puts_in_columns(data_by_columns, format) do



data_by_columns



|> List.zip



|> map(&Tuple.to_list/1)



|> each(&puts_one_line_in_columns(&1, format))



end





def puts_one_line_in_columns(fields, format) do



:io.format(format, fields)



end



end





Note how some of the documentation contains sample iex sessions.

Now we write a test that validates that each of the iex sessions returns the values shown in the @doc string. We create a new test file, test/doc_test.exs, containing this:

project/5/issues/test/doc_test.exs

defmodule DocTest do



use ExUnit.Case



» doctest Issues.TableFormatter



end





We can now run this:

$ mix test test/doc_test.exs



......



Finished in 0.00 seconds



5 tests, 0 failures





And, of course, these tests are integrated into the overall test suite:

$ mix test



..............



Finished in 0.01 seconds



13 tests, 0 failures





Let’s force an error to see what happens:

@doc """



Return a binary (string) version of our parameter.





## Examples





iex> Issues.TableFormatter.printable("a")



"a"



iex> Issues.TableFormatter.printable(99)



"99.0"



"""



def printable(str) when is_binary(str), do: str



def printable(str), do: to_string(str)





And run the tests again:

$ mix test test/doc_test.exs



.........



1) test doc at Issues.TableFormatter.printable/1 (3) (DocTest)



Doctest failed



code: " Issues.TableFormatter.printable(99) should equal \"99.0\""



lhs: "\"99\""



stacktrace:



lib/issues/table_formatter.ex:52: Issues.TableFormatter (module)



....



Finished in 0.01 seconds



6 tests, 1 failures





Task: Create Project Documentation


Java has Javadoc, Ruby has RDoc, and Elixir has ExDoc—a documentation tool that describes your project, showing the modules, the things defined in them, and any documentation you’ve written for them.

Using it is easy. First, add the ExDoc dependency to your mix.exs file. This dependency is unique—rather than drag it in from hex.pm, we’ll get it from GitHub.

project/5/issues/mix.exs

defp deps do



[



{ :httpoison, "~> 0.4" },



{ :jsx, "~> 2.0" },



{ :ex_doc, github: "elixir-lang/ex_doc" }



]



end





While you’re in the mix.exs, you can add a project name and (if your project is in GitHub) a URL. The latter allows ExDoc to provide live links to your source code. These parameters go in the project function:

def project do



[ app: :issues,



version: "0.0.1",



» name: "Issues",



» source_url: "https://github.com/pragdave/issues",



deps: deps ]



end





Then run mix deps.get.

To generate the documentation, just run

$ mix docs



Docs generated with success.



Open up docs/index.html in your browser to read them.





The first time you run it, this will install ExDoc. That involves compiling some C code, so you’ll need a development environment on your machine.

Open docs/index.html in your browser, then use the sidebar on the left to search or drill down through your modules. Here’s what I see for the start of the documentation for TableFormatter:



And that’s it. The full project is in the source download at project/5/issues.





Coding by Transforming Data


I wanted to show you how Elixir projects are written—the tools we use and the processes we follow. I wanted to illustrate how lots of small functions can transform data, how specifying that transformation acts as an outline for the program, and how easy testing can be in Elixir.

But mostly I wanted to show how enjoyable Elixir development is, and how thinking about the world in terms of data and its transformation is a productive way to code.

Let’s look at our original outline:



And then at the CLI.process function:

def process({user, project, count}) do



Issues.GithubIssues.fetch(user, project)



|> decode_response



|> convert_to_list_of_hashdicts



|> sort_into_ascending_order



|> Enum.take(count)



|> print_table_for_columns(["number", "created_at", "title"])



end





This is a cool way to code.

Next we’ll turn our attention to concurrent programming, a key strength of Elixir.





Your Turn


Exercise: OrganizingAProject-6

In the United States, the National Oceanic and Atmospheric Administration provides hourly XML feeds of conditions at 1,800 locations.[24] For example, the feed for a small airport close to where I’m writing this is at http://w1.weather.gov/xml/current_obs/KDTO.xml.

Write an application that fetches this data, parses it, and displays it in a nice format.

(Hint: You might not have to download a library to handle XML parsing.)





Footnotes


[18]

http://developer.github.com/v3/



[19]

http://elixir-lang.org/getting_started/mix_otp/1.html



[20]

http://elixir-lang.org/docs/stable/elixir/OptionParser.html



[21]

https://github.com/edgurgel/httpoison



[22]

https://github.com/talentdeficit/jsx



[23]

http://elixir-lang.org/docs/stable/elixir/HashDict.html



[24]

http://w1.weather.gov/xml/current_obs





Part 2

Concurrent Programming



You want to write concurrent programs. That’s probably why you’re reading this book.

Let’s look at Elixir’s actor-based concurrency model. Then we’ll dig into OTP, the Erlang management architecture that helps you create applications that are highly scalable and very reliable.

